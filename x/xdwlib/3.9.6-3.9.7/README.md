# Comparing `tmp/xdwlib-3.9.6.zip` & `tmp/xdwlib-3.9.7.zip`

## zipinfo {}

```diff
@@ -1,71 +1,70 @@
-Zip file size: 346440 bytes, number of entries: 69
-drwxrwxrwx  2.0 fat        0 b- stor 22-May-18 19:38 xdwlib-3.9.6/
-drwxrwxrwx  2.0 fat        0 b- stor 22-May-18 19:38 xdwlib-3.9.6/docs/
-drwxrwxrwx  2.0 fat        0 b- stor 22-May-18 19:38 xdwlib-3.9.6/scripts/
-drwxrwxrwx  2.0 fat        0 b- stor 22-May-18 19:38 xdwlib-3.9.6/xdwlib/
-drwxrwxrwx  2.0 fat        0 b- stor 22-May-18 19:38 xdwlib-3.9.6/xdwlib.egg-info/
--rw-rw-rw-  2.0 fat     1868 b- defN 22-Jan-30 10:04 xdwlib-3.9.6/cx_setup.py
--rw-rw-rw-  2.0 fat     2225 b- defN 21-Nov-17 12:38 xdwlib-3.9.6/LICENSE.rst
--rw-rw-rw-  2.0 fat      105 b- defN 21-Nov-15 19:22 xdwlib-3.9.6/MANIFEST.in
--rw-rw-rw-  2.0 fat     4590 b- defN 22-May-18 19:38 xdwlib-3.9.6/PKG-INFO
--rw-rw-rw-  2.0 fat     2781 b- defN 22-Jan-30 10:10 xdwlib-3.9.6/README.rst
--rw-rw-rw-  2.0 fat      984 b- defN 22-May-18 19:38 xdwlib-3.9.6/setup.cfg
--rw-rw-rw-  2.0 fat      221 b- defN 21-Nov-15 12:37 xdwlib-3.9.6/setup.py
--rw-rw-rw-  2.0 fat    43392 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/after.png
--rw-rw-rw-  2.0 fat     9262 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/annotatable.rst
--rw-rw-rw-  2.0 fat    24731 b- defN 22-Jan-18 16:20 xdwlib-3.9.6/docs/annotation.rst
--rw-rw-rw-  2.0 fat    17233 b- defN 22-Jan-18 16:20 xdwlib-3.9.6/docs/basedocument.rst
--rw-rw-rw-  2.0 fat    43458 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/before.png
--rw-rw-rw-  2.0 fat     8332 b- defN 22-Feb-19 20:47 xdwlib-3.9.6/docs/binder.rst
--rw-rw-rw-  2.0 fat     1505 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/colors.rst
--rw-rw-rw-  2.0 fat     2188 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/conf.py
--rw-rw-rw-  2.0 fat      114 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/cx_setup.rst
--rw-rw-rw-  2.0 fat      514 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/derivativepath.rst
--rw-rw-rw-  2.0 fat     7601 b- defN 22-Jan-23 18:26 xdwlib-3.9.6/docs/document.rst
--rw-rw-rw-  2.0 fat     2751 b- defN 22-Jan-25 14:41 xdwlib-3.9.6/docs/documentinbinder.rst
--rw-rw-rw-  2.0 fat      802 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/faq.rst
--rw-rw-rw-  2.0 fat     1900 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/fonts.rst
--rw-rw-rw-  2.0 fat     1803 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/halfopenregion.rst
--rw-rw-rw-  2.0 fat     7371 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/horizontal_split-settings.png
--rw-rw-rw-  2.0 fat    18848 b- defN 22-Jan-18 16:20 xdwlib-3.9.6/docs/howto.rst
--rw-rw-rw-  2.0 fat      653 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/index.rst
--rwx---     2.0 fat      795 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/make.bat
--rw-rw-rw-  2.0 fat      634 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/Makefile
--rw-rw-rw-  2.0 fat    57904 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/mark_screenshot.png
--rw-rw-rw-  2.0 fat    34307 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/merged.png
--rw-rw-rw-  2.0 fat     9514 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/mergetest.jpg
--rw-rw-rw-  2.0 fat       88 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/modules.rst
--rw-rw-rw-  2.0 fat     3321 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/overview.rst
--rw-rw-rw-  2.0 fat    25268 b- defN 22-Jan-20 19:29 xdwlib-3.9.6/docs/page.rst
--rw-rw-rw-  2.0 fat    12558 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/samples.rst
--rw-rw-rw-  2.0 fat      103 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/setup.rst
--rw-rw-rw-  2.0 fat     7995 b- defN 22-Jan-18 16:20 xdwlib-3.9.6/docs/struct.rst
--rw-rw-rw-  2.0 fat     5769 b- defN 22-Jan-04 21:24 xdwlib-3.9.6/docs/whatsthis.rst
--rw-rw-rw-  2.0 fat      112 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/xdw2text.rst
--rw-rw-rw-  2.0 fat    35795 b- defN 22-Jan-25 14:40 xdwlib-3.9.6/docs/xdwfile.rst
--rw-rw-rw-  2.0 fat     2178 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/xdwlib.rst
--rw-rw-rw-  2.0 fat     2230 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/docs/xdwtemp.rst
--rw-rw-rw-  2.0 fat     4314 b- defN 21-Nov-17 12:37 xdwlib-3.9.6/scripts/xdw2text.py
--rw-rw-rw-  2.0 fat    18376 b- defN 22-Jan-20 02:15 xdwlib-3.9.6/xdwlib/annotatable.py
--rw-rw-rw-  2.0 fat    23672 b- defN 22-Jan-24 19:35 xdwlib-3.9.6/xdwlib/annotation.py
--rw-rw-rw-  2.0 fat    23188 b- defN 22-Jan-23 17:26 xdwlib-3.9.6/xdwlib/basedocument.py
--rw-rw-rw-  2.0 fat     9315 b- defN 22-Jan-22 12:44 xdwlib-3.9.6/xdwlib/binder.py
--rw-rw-rw-  2.0 fat     4001 b- defN 22-Apr-01 12:01 xdwlib-3.9.6/xdwlib/bitmap.py
--rw-rw-rw-  2.0 fat    13104 b- defN 22-Jan-28 00:07 xdwlib-3.9.6/xdwlib/common.py
--rw-rw-rw-  2.0 fat     9493 b- defN 22-Feb-19 20:42 xdwlib-3.9.6/xdwlib/document.py
--rw-rw-rw-  2.0 fat     4490 b- defN 22-Jan-22 01:24 xdwlib-3.9.6/xdwlib/documentinbinder.py
--rw-rw-rw-  2.0 fat     1823 b- defN 22-Jan-04 21:23 xdwlib-3.9.6/xdwlib/observer.py
--rw-rw-rw-  2.0 fat    36543 b- defN 22-Feb-16 16:03 xdwlib-3.9.6/xdwlib/page.py
--rw-rw-rw-  2.0 fat     6376 b- defN 22-Jan-27 23:20 xdwlib-3.9.6/xdwlib/struct.py
--rw-rw-rw-  2.0 fat     1260 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/xdwlib/timezone.py
--rw-rw-rw-  2.0 fat   111403 b- defN 22-Apr-14 12:31 xdwlib-3.9.6/xdwlib/xdwapi.py
--rw-rw-rw-  2.0 fat    43237 b- defN 22-Apr-13 14:07 xdwlib-3.9.6/xdwlib/xdwfile.py
--rw-rw-rw-  2.0 fat     3320 b- defN 20-Nov-06 21:52 xdwlib-3.9.6/xdwlib/xdwtemp.py
--rw-rw-rw-  2.0 fat     1121 b- defN 22-Feb-19 20:43 xdwlib-3.9.6/xdwlib/__init__.py
--rw-rw-rw-  2.0 fat      932 b- defN 22-Apr-14 16:31 xdwlib-3.9.6/xdwlib/__setup__.py
--rw-rw-rw-  2.0 fat        1 b- defN 22-May-18 19:38 xdwlib-3.9.6/xdwlib.egg-info/dependency_links.txt
--rw-rw-rw-  2.0 fat        2 b- defN 21-Nov-15 18:40 xdwlib-3.9.6/xdwlib.egg-info/not-zip-safe
--rw-rw-rw-  2.0 fat     4590 b- defN 22-May-18 19:38 xdwlib-3.9.6/xdwlib.egg-info/PKG-INFO
--rw-rw-rw-  2.0 fat     1173 b- defN 22-May-18 19:38 xdwlib-3.9.6/xdwlib.egg-info/SOURCES.txt
--rw-rw-rw-  2.0 fat        7 b- defN 22-May-18 19:38 xdwlib-3.9.6/xdwlib.egg-info/top_level.txt
-69 files, 725544 bytes uncompressed, 337070 bytes compressed:  53.5%
+Zip file size: 346822 bytes, number of entries: 68
+drwxrwxrwx  2.0 fat        0 b- stor 22-Dec-15 20:11 xdwlib-3.9.7/
+drwxrwxrwx  2.0 fat        0 b- stor 22-Dec-15 20:11 xdwlib-3.9.7/docs/
+drwxrwxrwx  2.0 fat        0 b- stor 22-Dec-15 20:11 xdwlib-3.9.7/scripts/
+drwxrwxrwx  2.0 fat        0 b- stor 22-Dec-15 20:11 xdwlib-3.9.7/xdwlib/
+drwxrwxrwx  2.0 fat        0 b- stor 22-Dec-15 20:11 xdwlib-3.9.7/xdwlib.egg-info/
+-rw-rw-rw-  2.0 fat     1868 b- defN 22-Jan-30 10:04 xdwlib-3.9.7/cx_setup.py
+-rw-rw-rw-  2.0 fat     2225 b- defN 21-Nov-17 12:38 xdwlib-3.9.7/LICENSE.rst
+-rw-rw-rw-  2.0 fat      105 b- defN 21-Nov-15 19:22 xdwlib-3.9.7/MANIFEST.in
+-rw-rw-rw-  2.0 fat     4869 b- defN 22-Dec-15 20:11 xdwlib-3.9.7/PKG-INFO
+-rw-rw-rw-  2.0 fat     2988 b- defN 22-Nov-10 13:44 xdwlib-3.9.7/README.rst
+-rw-rw-rw-  2.0 fat      984 b- defN 22-Dec-15 20:11 xdwlib-3.9.7/setup.cfg
+-rw-rw-rw-  2.0 fat      221 b- defN 21-Nov-15 12:37 xdwlib-3.9.7/setup.py
+-rw-rw-rw-  2.0 fat    43392 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/after.png
+-rw-rw-rw-  2.0 fat     9262 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/annotatable.rst
+-rw-rw-rw-  2.0 fat    24731 b- defN 22-Jan-18 16:20 xdwlib-3.9.7/docs/annotation.rst
+-rw-rw-rw-  2.0 fat    17233 b- defN 22-Jan-18 16:20 xdwlib-3.9.7/docs/basedocument.rst
+-rw-rw-rw-  2.0 fat    43458 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/before.png
+-rw-rw-rw-  2.0 fat     8332 b- defN 22-Feb-19 20:47 xdwlib-3.9.7/docs/binder.rst
+-rw-rw-rw-  2.0 fat     1505 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/colors.rst
+-rw-rw-rw-  2.0 fat     2222 b- defN 22-Nov-02 16:42 xdwlib-3.9.7/docs/conf.py
+-rw-rw-rw-  2.0 fat      114 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/cx_setup.rst
+-rw-rw-rw-  2.0 fat      514 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/derivativepath.rst
+-rw-rw-rw-  2.0 fat     7601 b- defN 22-Jan-23 18:26 xdwlib-3.9.7/docs/document.rst
+-rw-rw-rw-  2.0 fat     2751 b- defN 22-Jan-25 14:41 xdwlib-3.9.7/docs/documentinbinder.rst
+-rw-rw-rw-  2.0 fat      802 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/faq.rst
+-rw-rw-rw-  2.0 fat     1904 b- defN 22-Dec-14 16:55 xdwlib-3.9.7/docs/fonts.rst
+-rw-rw-rw-  2.0 fat     1803 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/halfopenregion.rst
+-rw-rw-rw-  2.0 fat     7371 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/horizontal_split-settings.png
+-rw-rw-rw-  2.0 fat    18846 b- defN 22-Nov-10 13:47 xdwlib-3.9.7/docs/howto.rst
+-rw-rw-rw-  2.0 fat     6562 b- defN 22-Nov-05 18:33 xdwlib-3.9.7/docs/index.rst
+-rwx---     2.0 fat      795 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/make.bat
+-rw-rw-rw-  2.0 fat      634 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/Makefile
+-rw-rw-rw-  2.0 fat    57904 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/mark_screenshot.png
+-rw-rw-rw-  2.0 fat    34307 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/merged.png
+-rw-rw-rw-  2.0 fat     9514 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/mergetest.jpg
+-rw-rw-rw-  2.0 fat       88 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/modules.rst
+-rw-rw-rw-  2.0 fat     3321 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/overview.rst
+-rw-rw-rw-  2.0 fat    25268 b- defN 22-Jan-20 19:29 xdwlib-3.9.7/docs/page.rst
+-rw-rw-rw-  2.0 fat    12751 b- defN 22-Nov-10 17:59 xdwlib-3.9.7/docs/samples.rst
+-rw-rw-rw-  2.0 fat      103 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/setup.rst
+-rw-rw-rw-  2.0 fat     7995 b- defN 22-Jan-18 16:20 xdwlib-3.9.7/docs/struct.rst
+-rw-rw-rw-  2.0 fat      112 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/xdw2text.rst
+-rw-rw-rw-  2.0 fat    35795 b- defN 22-Jan-25 14:40 xdwlib-3.9.7/docs/xdwfile.rst
+-rw-rw-rw-  2.0 fat     2178 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/xdwlib.rst
+-rw-rw-rw-  2.0 fat     2230 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/docs/xdwtemp.rst
+-rw-rw-rw-  2.0 fat     4314 b- defN 21-Nov-17 12:37 xdwlib-3.9.7/scripts/xdw2text.py
+-rw-rw-rw-  2.0 fat    18376 b- defN 22-Dec-14 18:21 xdwlib-3.9.7/xdwlib/annotatable.py
+-rw-rw-rw-  2.0 fat    23673 b- defN 22-Dec-15 20:06 xdwlib-3.9.7/xdwlib/annotation.py
+-rw-rw-rw-  2.0 fat    23188 b- defN 22-Jan-23 17:26 xdwlib-3.9.7/xdwlib/basedocument.py
+-rw-rw-rw-  2.0 fat     9315 b- defN 22-Jan-22 12:44 xdwlib-3.9.7/xdwlib/binder.py
+-rw-rw-rw-  2.0 fat     4001 b- defN 22-Apr-01 12:01 xdwlib-3.9.7/xdwlib/bitmap.py
+-rw-rw-rw-  2.0 fat    13104 b- defN 22-Jan-28 00:07 xdwlib-3.9.7/xdwlib/common.py
+-rw-rw-rw-  2.0 fat     9493 b- defN 22-Feb-19 20:42 xdwlib-3.9.7/xdwlib/document.py
+-rw-rw-rw-  2.0 fat     4490 b- defN 22-Jan-22 01:24 xdwlib-3.9.7/xdwlib/documentinbinder.py
+-rw-rw-rw-  2.0 fat     1823 b- defN 22-Jan-04 21:23 xdwlib-3.9.7/xdwlib/observer.py
+-rw-rw-rw-  2.0 fat    36543 b- defN 22-Feb-16 16:03 xdwlib-3.9.7/xdwlib/page.py
+-rw-rw-rw-  2.0 fat     6376 b- defN 22-Jan-27 23:20 xdwlib-3.9.7/xdwlib/struct.py
+-rw-rw-rw-  2.0 fat     1260 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/xdwlib/timezone.py
+-rw-rw-rw-  2.0 fat   111413 b- defN 22-Dec-15 20:08 xdwlib-3.9.7/xdwlib/xdwapi.py
+-rw-rw-rw-  2.0 fat    44517 b- defN 22-Jun-09 14:57 xdwlib-3.9.7/xdwlib/xdwfile.py
+-rw-rw-rw-  2.0 fat     3320 b- defN 20-Nov-06 21:52 xdwlib-3.9.7/xdwlib/xdwtemp.py
+-rw-rw-rw-  2.0 fat     1121 b- defN 22-Feb-19 20:43 xdwlib-3.9.7/xdwlib/__init__.py
+-rw-rw-rw-  2.0 fat      932 b- defN 22-Dec-15 20:09 xdwlib-3.9.7/xdwlib/__setup__.py
+-rw-rw-rw-  2.0 fat        1 b- defN 22-Dec-15 20:11 xdwlib-3.9.7/xdwlib.egg-info/dependency_links.txt
+-rw-rw-rw-  2.0 fat        2 b- defN 21-Nov-15 18:40 xdwlib-3.9.7/xdwlib.egg-info/not-zip-safe
+-rw-rw-rw-  2.0 fat     4869 b- defN 22-Dec-15 20:11 xdwlib-3.9.7/xdwlib.egg-info/PKG-INFO
+-rw-rw-rw-  2.0 fat     1154 b- defN 22-Dec-15 20:11 xdwlib-3.9.7/xdwlib.egg-info/SOURCES.txt
+-rw-rw-rw-  2.0 fat        7 b- defN 22-Dec-15 20:11 xdwlib-3.9.7/xdwlib.egg-info/top_level.txt
+68 files, 727950 bytes uncompressed, 337590 bytes compressed:  53.6%
```

## zipnote {}

```diff
@@ -1,208 +1,205 @@
-Filename: xdwlib-3.9.6/
+Filename: xdwlib-3.9.7/
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/
+Filename: xdwlib-3.9.7/docs/
 Comment: 
 
-Filename: xdwlib-3.9.6/scripts/
+Filename: xdwlib-3.9.7/scripts/
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/
+Filename: xdwlib-3.9.7/xdwlib/
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib.egg-info/
+Filename: xdwlib-3.9.7/xdwlib.egg-info/
 Comment: 
 
-Filename: xdwlib-3.9.6/cx_setup.py
+Filename: xdwlib-3.9.7/cx_setup.py
 Comment: 
 
-Filename: xdwlib-3.9.6/LICENSE.rst
+Filename: xdwlib-3.9.7/LICENSE.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/MANIFEST.in
+Filename: xdwlib-3.9.7/MANIFEST.in
 Comment: 
 
-Filename: xdwlib-3.9.6/PKG-INFO
+Filename: xdwlib-3.9.7/PKG-INFO
 Comment: 
 
-Filename: xdwlib-3.9.6/README.rst
+Filename: xdwlib-3.9.7/README.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/setup.cfg
+Filename: xdwlib-3.9.7/setup.cfg
 Comment: 
 
-Filename: xdwlib-3.9.6/setup.py
+Filename: xdwlib-3.9.7/setup.py
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/after.png
+Filename: xdwlib-3.9.7/docs/after.png
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/annotatable.rst
+Filename: xdwlib-3.9.7/docs/annotatable.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/annotation.rst
+Filename: xdwlib-3.9.7/docs/annotation.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/basedocument.rst
+Filename: xdwlib-3.9.7/docs/basedocument.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/before.png
+Filename: xdwlib-3.9.7/docs/before.png
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/binder.rst
+Filename: xdwlib-3.9.7/docs/binder.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/colors.rst
+Filename: xdwlib-3.9.7/docs/colors.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/conf.py
+Filename: xdwlib-3.9.7/docs/conf.py
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/cx_setup.rst
+Filename: xdwlib-3.9.7/docs/cx_setup.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/derivativepath.rst
+Filename: xdwlib-3.9.7/docs/derivativepath.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/document.rst
+Filename: xdwlib-3.9.7/docs/document.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/documentinbinder.rst
+Filename: xdwlib-3.9.7/docs/documentinbinder.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/faq.rst
+Filename: xdwlib-3.9.7/docs/faq.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/fonts.rst
+Filename: xdwlib-3.9.7/docs/fonts.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/halfopenregion.rst
+Filename: xdwlib-3.9.7/docs/halfopenregion.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/horizontal_split-settings.png
+Filename: xdwlib-3.9.7/docs/horizontal_split-settings.png
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/howto.rst
+Filename: xdwlib-3.9.7/docs/howto.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/index.rst
+Filename: xdwlib-3.9.7/docs/index.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/make.bat
+Filename: xdwlib-3.9.7/docs/make.bat
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/Makefile
+Filename: xdwlib-3.9.7/docs/Makefile
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/mark_screenshot.png
+Filename: xdwlib-3.9.7/docs/mark_screenshot.png
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/merged.png
+Filename: xdwlib-3.9.7/docs/merged.png
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/mergetest.jpg
+Filename: xdwlib-3.9.7/docs/mergetest.jpg
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/modules.rst
+Filename: xdwlib-3.9.7/docs/modules.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/overview.rst
+Filename: xdwlib-3.9.7/docs/overview.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/page.rst
+Filename: xdwlib-3.9.7/docs/page.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/samples.rst
+Filename: xdwlib-3.9.7/docs/samples.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/setup.rst
+Filename: xdwlib-3.9.7/docs/setup.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/struct.rst
+Filename: xdwlib-3.9.7/docs/struct.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/whatsthis.rst
+Filename: xdwlib-3.9.7/docs/xdw2text.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/xdw2text.rst
+Filename: xdwlib-3.9.7/docs/xdwfile.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/xdwfile.rst
+Filename: xdwlib-3.9.7/docs/xdwlib.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/xdwlib.rst
+Filename: xdwlib-3.9.7/docs/xdwtemp.rst
 Comment: 
 
-Filename: xdwlib-3.9.6/docs/xdwtemp.rst
+Filename: xdwlib-3.9.7/scripts/xdw2text.py
 Comment: 
 
-Filename: xdwlib-3.9.6/scripts/xdw2text.py
+Filename: xdwlib-3.9.7/xdwlib/annotatable.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/annotatable.py
+Filename: xdwlib-3.9.7/xdwlib/annotation.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/annotation.py
+Filename: xdwlib-3.9.7/xdwlib/basedocument.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/basedocument.py
+Filename: xdwlib-3.9.7/xdwlib/binder.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/binder.py
+Filename: xdwlib-3.9.7/xdwlib/bitmap.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/bitmap.py
+Filename: xdwlib-3.9.7/xdwlib/common.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/common.py
+Filename: xdwlib-3.9.7/xdwlib/document.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/document.py
+Filename: xdwlib-3.9.7/xdwlib/documentinbinder.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/documentinbinder.py
+Filename: xdwlib-3.9.7/xdwlib/observer.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/observer.py
+Filename: xdwlib-3.9.7/xdwlib/page.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/page.py
+Filename: xdwlib-3.9.7/xdwlib/struct.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/struct.py
+Filename: xdwlib-3.9.7/xdwlib/timezone.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/timezone.py
+Filename: xdwlib-3.9.7/xdwlib/xdwapi.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/xdwapi.py
+Filename: xdwlib-3.9.7/xdwlib/xdwfile.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/xdwfile.py
+Filename: xdwlib-3.9.7/xdwlib/xdwtemp.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/xdwtemp.py
+Filename: xdwlib-3.9.7/xdwlib/__init__.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/__init__.py
+Filename: xdwlib-3.9.7/xdwlib/__setup__.py
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib/__setup__.py
+Filename: xdwlib-3.9.7/xdwlib.egg-info/dependency_links.txt
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib.egg-info/dependency_links.txt
+Filename: xdwlib-3.9.7/xdwlib.egg-info/not-zip-safe
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib.egg-info/not-zip-safe
+Filename: xdwlib-3.9.7/xdwlib.egg-info/PKG-INFO
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib.egg-info/PKG-INFO
+Filename: xdwlib-3.9.7/xdwlib.egg-info/SOURCES.txt
 Comment: 
 
-Filename: xdwlib-3.9.6/xdwlib.egg-info/SOURCES.txt
-Comment: 
-
-Filename: xdwlib-3.9.6/xdwlib.egg-info/top_level.txt
+Filename: xdwlib-3.9.7/xdwlib.egg-info/top_level.txt
 Comment: 
 
 Zip file comment:
```

## Comparing `xdwlib-3.9.6/cx_setup.py` & `xdwlib-3.9.7/cx_setup.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/LICENSE.rst` & `xdwlib-3.9.7/LICENSE.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/PKG-INFO` & `xdwlib-3.9.7/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 Metadata-Version: 1.2
 Name: xdwlib
-Version: 3.9.6
+Version: 3.9.7
 Summary: A DocuWorks library.
 Home-page: https://github.com/hayasix/xdwlib
 Author: HAYASHI Hideki
 Author-email: hideki@hayasix.com
 License: UNKNOWN
 Description: =============
         Xdwlib README
         =============
         
-        2022-01-30 HAYASHI Hideki <hideki@hayasix.com>
+        2022-11-08 HAYASHI Hideki <hideki@hayasix.com>
         
         
         Welcome to the xdwlib source release
         ====================================
         
         Xdwlib is a DocuWorks library for Python.
         
@@ -90,14 +90,23 @@
         with cx_Freeze package, a popular successor of py2exe.  To build your
         own ``xdw2text.exe``, try::
         
             pip3 install cx_Freeze
             python3 cx_setup.py build
         
         
+        Documentation
+        =============
+        
+        Detailed documents are available in Japanese at
+        `Read the Docs <https://xdwlib.readthedocs.io/ja/latest>`_.
+        
+        Python's help() also gives brief descriptions in English.
+        
+        
         Typical Use
         ===========
         
         The following code will appy OCR and paste a date stamp on every page
         as an annotation::
         
             import time
```

## Comparing `xdwlib-3.9.6/README.rst` & `xdwlib-3.9.7/README.rst`

 * *Files 16% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 =============
 Xdwlib README
 =============
 
-2022-01-30 HAYASHI Hideki <hideki@hayasix.com>
+2022-11-08 HAYASHI Hideki <hideki@hayasix.com>
 
 
 Welcome to the xdwlib source release
 ====================================
 
 Xdwlib is a DocuWorks library for Python.
 
@@ -82,14 +82,23 @@
 with cx_Freeze package, a popular successor of py2exe.  To build your
 own ``xdw2text.exe``, try::
 
     pip3 install cx_Freeze
     python3 cx_setup.py build
 
 
+Documentation
+=============
+
+Detailed documents are available in Japanese at
+`Read the Docs <https://xdwlib.readthedocs.io/ja/latest>`_.
+
+Python's help() also gives brief descriptions in English.
+
+
 Typical Use
 ===========
 
 The following code will appy OCR and paste a date stamp on every page
 as an annotation::
 
     import time
```

## Comparing `xdwlib-3.9.6/setup.cfg` & `xdwlib-3.9.7/setup.cfg`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/after.png` & `xdwlib-3.9.7/docs/after.png`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/annotatable.rst` & `xdwlib-3.9.7/docs/annotatable.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/annotation.rst` & `xdwlib-3.9.7/docs/annotation.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/basedocument.rst` & `xdwlib-3.9.7/docs/basedocument.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/before.png` & `xdwlib-3.9.7/docs/before.png`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/binder.rst` & `xdwlib-3.9.7/docs/binder.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/colors.rst` & `xdwlib-3.9.7/docs/colors.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/conf.py` & `xdwlib-3.9.7/docs/conf.py`

 * *Files 2% similar despite different names*

```diff
@@ -47,13 +47,14 @@
 
 
 # -- Options for HTML output -------------------------------------------------
 
 # The theme to use for HTML and HTML Help pages.  See the documentation for
 # a list of builtin themes.
 #
-html_theme = 'alabaster'
+#html_theme = 'alabaster'
+html_theme = 'sphinx_rtd_theme'
 
 # Add any paths that contain custom static files (such as style sheets) here,
 # relative to this directory. They are copied after the builtin static files,
 # so a file named "default.css" will overwrite the builtin "default.css".
 html_static_path = ['_static']
```

## Comparing `xdwlib-3.9.6/docs/derivativepath.rst` & `xdwlib-3.9.7/docs/derivativepath.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/document.rst` & `xdwlib-3.9.7/docs/document.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/documentinbinder.rst` & `xdwlib-3.9.7/docs/documentinbinder.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/faq.rst` & `xdwlib-3.9.7/docs/faq.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/fonts.rst` & `xdwlib-3.9.7/docs/fonts.rst`

 * *Files 2% similar despite different names*

```diff
@@ -26,13 +26,13 @@
     ``'VARIABLE_PITCH'``, ``'MONO_FONT'``) およびファミリ (``'ROMAN'``,
     ``'SWISS'``, ``'MODERN'``, ``'SCRIPT'``, ``'DECORATIVE'``)
     の組み合わせ (カンマ ``','`` で ``join`` します) で指定します
     (小文字でもかまいません)。ピッチ・ファミリの片方だけを指定することも
     でき、その場合は指定していない方はシステム既定値となります。初期値は
     ``'FIXED_PITCH,ROMAN'`` です。
 
-font_char_set
+``font_char_set``
     フォントの文字セットです。 ``'DEFAULT'``, ``'ANSI'``, ``'SYMBOL'``,
     ``'MAC'``, ``'SHIFTJIS'``, ``'HANGEUL'``, ``'CHINESEBIG5'``,
     ``'GREEK'``, ``'TURKISH'``, ``'BALTIC'``, ``'RUSSIAN'``,
     ``'EASTEUROPE'``, ``'OEM'`` のいずれかで指定します
     (小文字でもかまいません)。初期値は ``'SHIFTJIS'`` です。
```

## Comparing `xdwlib-3.9.6/docs/halfopenregion.rst` & `xdwlib-3.9.7/docs/halfopenregion.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/horizontal_split-settings.png` & `xdwlib-3.9.7/docs/horizontal_split-settings.png`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/howto.rst` & `xdwlib-3.9.7/docs/howto.rst`

 * *Files 0% similar despite different names*

```diff
@@ -249,16 +249,16 @@
 設定してください。
 
 ::
 
     from xdwlib.struct import Point
     : (中略)
     pg = doc.page(0)
-    ann = pg.add_text(u"変更前の文字列") # 既定の位置にテキストアノテーションを貼り付けます。
-    ann.text = u"変更後の文字列"
+    ann = pg.add_text("変更前の文字列") # 既定の位置にテキストアノテーションを貼り付けます。
+    ann.text = "変更後の文字列"
     ann.font_size = 10.5 # ポイント
     ann.font_style = "bold,italic"
     ann.fore_color = "red"
     ann.back_color = "none"
     ann.position = Point(pg.size.x - 200, 75) # 右から 200mm, 上から 75mm の位置へ移動します。
 
 ただし、最終的に ``doc.save()`` を行わなければファイルの内容は変更されない
```

## Comparing `xdwlib-3.9.6/docs/make.bat` & `xdwlib-3.9.7/docs/make.bat`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/Makefile` & `xdwlib-3.9.7/docs/Makefile`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/mark_screenshot.png` & `xdwlib-3.9.7/docs/mark_screenshot.png`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/merged.png` & `xdwlib-3.9.7/docs/merged.png`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/mergetest.jpg` & `xdwlib-3.9.7/docs/mergetest.jpg`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/overview.rst` & `xdwlib-3.9.7/docs/overview.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/page.rst` & `xdwlib-3.9.7/docs/page.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/samples.rst` & `xdwlib-3.9.7/docs/samples.rst`

 * *Files 6% similar despite different names*

```diff
@@ -110,15 +110,15 @@
     C:\test> python mark.py "プラグ\w*?設定" "C:\test\PLUGINSPI-2.xdw"
 
 (実行結果)
 
 .. image:: mark_screenshot.png
     :align: left
     :scale: 200%
-    :alt: ``mark.py`` の実行結果の例。検索でみつかった場所にマークし、ページに付箋を貼ってあります。 
+    :alt: ``mark.py`` の実行結果の例。検索でみつかった場所にマークし、ページに付箋を貼ってあります。
 
 見開き書類をページごとに分割
 ============================
 
 たとえば、A4R 判左綴じの文書を見開き (A3 判) でスキャンして作った [1]_
 ドキュメントを、ページごとに切り分けて A4R 判のドキュメントに変換します。
 ページ数が倍のドキュメントができあがります。
@@ -144,15 +144,15 @@
     from xdwlib.struct import Point
 
     infile = sys.argv[1]
 
     if os.path.splitext(infile)[1].lower() != ".xdw":
         raise ValueError("file must be *.xdw")
 
-    newfile = infile[:-4] + u"-左右分割.xdw"
+    newfile = infile[:-4] + "-左右分割.xdw"
 
     with xdwopen(infile) as doc:
         pages = doc.pages
         for pg in doc[:pages]:
             degree = pg.degree
             # A3見開き→A4×2ページのようにするため、取り込み時のページ幅は半分にします。
             # スキャン時の画像の向きを考慮して引数を設定していきます。
@@ -180,47 +180,51 @@
             # 一時ファイルを消去します。
             os.remove(temp)
         # 分割前のページは不要になるので削除します。
         del doc[:pages]
         # 分割前のファイルは残し、新たなファイルへ保存します。
         PageCollection(doc).export(newfile, flat=True)
 
-
 (実行例)
 
 ::
 
     C:\test> python horizontal_split.py "C:\test\DocuShare.xdw"
 
 (実行前)
 
 .. image:: before.png
     :align: left
     :scale: 200%
+    :alt: 元の A3 文書
 
 (実行後)
 
 .. image:: after.png
     :align: left
     :scale: 200%
+    :alt: A3 を左右に分割して A4 に変換した文書
 
 応用編として、このプログラムを py2exe で実行形式にした上で、DocuWorks の
 プラグインの設定で「外部コマンドの起動」を追加すると、クリックひとつで
 イメージドキュメントのページ分割ができるようになります。
 
 (設定例)
 
 .. image:: horizontal_split-settings.png
     :align: left
     :scale: 200%
-    :alt: horizontal_split.exe 用の外部コマンドの設定 
+    :alt: horizontal_split.exe 用の外部コマンドの設定
+
+実際に動作する DocuWorks プラグインを置いておきます。ただし、かなり古いバージョンで作成したものです。
+
+:download:`horizontal_split.zip <../horizontal_split.zip>`
 
-このページの下部に、実際に動作する DocuWorks プラグインを置いておきます。
-zip ファイルを展開すると horizontal_split.exe が取り出せるので、それを
-「外部コマンドの起動」で実行モジュールのパスとして指定してください。
+zip ファイルを展開すると ``horizontal_split.exe`` が取り出せるので、
+それを「外部コマンドの起動」で実行モジュールのパスとして指定してください。
 その他の設定は上図に準じます。
 
 差し込み処理
 ============
 
 DocuWorks 文書に対してデータの差し込みを行います。
```

## Comparing `xdwlib-3.9.6/docs/struct.rst` & `xdwlib-3.9.7/docs/struct.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/whatsthis.rst` & `xdwlib-3.9.7/docs/index.rst`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,21 @@
-=========
+.. xdwlib documentation master file, created by
+   sphinx-quickstart on Mon Jul  8 16:45:53 2019.
+   You can adapt this file completely to your liking, but it should at least
+   contain the root `toctree` directive.
+
+=================================
+xdwlib - Python DocuWorks Library
+=================================
+
 これは何?
 =========
 
-富士ゼロックス株式会社から発売されているロングセラー DocuWorks™ は、
-オフィスワーカーにやさしい電子ファイリングシステムです。
+富士フイルムビジネスイノベーション株式会社 (FFBI) から発売されているロングセラー
+DocuWorks™ は、オフィスワーカーにやさしい電子ファイリングシステムです。
 蓄積した電子文書を有効に活用するには、単にアプリケーションを使うだけでなく、
 外部プログラムから操作できた方がいいと思いませんか?
 できれば、C++ や Java ではなくて、もっとフレンドリーな Python (日本語) で
 使いたいものですね。
 そこで、Python DocuWorks Library (xdwlib) を作ってみました!
 
 私にも役に立つの?
@@ -19,17 +27,17 @@
 Python は学びやすいプログラミング言語ですが、まったくのプログラミング初心者が
 自由に使えるようになるには、相応の時間がかかるでしょう。そういう方は、
 Python プログラマが素敵なアプリケーションを作ってくれるのを待ちましょう。
 
 何ができるの?
 =============
 
-製造元である富士ゼロックス株式会社が提供している開発ツール (DocuWorks™
-Development Tool Kit) に含まれる DocuWorks API (XDWAPI) の機能は
-API のレベルでは網羅しているので、基本的な作業はだいたいすべてできます。
+製造元である FFBI が提供している開発ツール (DocuWorks™ Development Tool Kit)
+に含まれる DocuWorks API (XDWAPI) の機能は API のレベルでは網羅しているので、
+基本的な作業はだいたいすべてできます。
 DocuWorks Desk は XDWAPI 以上の機能を持っているので、特殊な作業は手作業で
 行う必要があるでしょう。しかし、日常の基本的な作業を自動化 (バッチ処理化)
 するには、xdwlib で十分です。
 
 現時点での主な機能は、次のとおりです [1]_ 。
 
 .. [1] いずれも DocuWorks™ をインストールした状態で使えるものです。
@@ -75,24 +83,54 @@
     保存されています。
 
 また、Python Imaging Library (PIL) がインストールされていると、ページの任意角度 (90/180/270度以外) での回転が可能になります。
 
 どこにあるの?
 =============
 
-``easy_install xdwlib`` でインストールできます。easy_install を利用するには
-setuptools をインストールしてください。
+``pip install xdwlib`` または ``easy_install xdwlib`` でインストールできます。
+easy_install を利用するには setuptools をインストールしてください。
 
 開発版は、GitHub https://github.com/hayasix/xdwlib にあります。
 
 ::
 
     git clone https://github.com/hayasix/xdwlib.git master
 
 でコードを入手できます。
 
 作者は中の人?
 =============
 
-いいえ。作者は富士ゼロックス株式会社とは関係がありません。
+いいえ。作者は FFBI やその前身の富士ゼロックス株式会社とは関係がありません。
 xdwlib に関するご意見・ご要望は作者 (`林秀樹 <mailto:hideki@hayasix.com>`_)
 へお寄せください。
+
+.. toctree::
+    :hidden:
+    :maxdepth: 2
+
+    overview
+    xdwfile
+    binder
+    document
+    documentinbinder
+    basedocument
+    page
+    annotation
+    annotatable
+    struct
+    xdwtemp
+    derivativepath
+    halfopenregion
+    colors
+    fonts
+    howto
+    samples
+    faq
+
+Indices and tables
+==================
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
```

## Comparing `xdwlib-3.9.6/docs/xdwfile.rst` & `xdwlib-3.9.7/docs/xdwfile.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/xdwlib.rst` & `xdwlib-3.9.7/docs/xdwlib.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/docs/xdwtemp.rst` & `xdwlib-3.9.7/docs/xdwtemp.rst`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/scripts/xdw2text.py` & `xdwlib-3.9.7/scripts/xdw2text.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/annotatable.py` & `xdwlib-3.9.7/xdwlib/annotatable.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/annotation.py` & `xdwlib-3.9.7/xdwlib/annotation.py`

 * *Files 2% similar despite different names*

```diff
@@ -243,15 +243,15 @@
         elif data_type == XDW_ATYPE_DATE:  # unsupported in SDK
             return f"<<DATE:{value}>>"
         elif data_type == XDW_ATYPE_BOOL:  # unsupported in SDK
             return f"<<BOOL:{value}>>"
         elif data_type == XDW_ATYPE_OCTS:  # unsupported in SDK
             return f"<<OCTS:{value}>>"
         elif data_type == XDW_ATYPE_OTHER:  # Quick hack for points.
-            print(data_type, value)
+            #print(data_type, value)
             points = [Point(
                     scale(attrname, p.x),
                     scale(attrname, p.y)) for p in value]
             return absolute_points(points)
         else:
             return f"<<TYPE{data_type}:{value}>>"
 
@@ -283,27 +283,27 @@
                         XDW_ATYPE_INT,
                         byref(value),
                         0,
                         0)
             elif t == 1:
                 if not isinstance(value, str):
                     raise ValueError(
-                            "text data required, numeric given")
+                            f'text data required, non-text {value} given')
                 if (self.is_unicode and
                     XDW_ANNOTATION_TYPE.normalize(self.type) in (
                         XDW_ATN_Text,
                         XDW_ATN_Caption, XDW_ATN_Url, XDW_ATN_XdwPath,
                         XDW_ATN_XdwNameInXbd, XDW_ATN_Tooltip_String,
                         XDW_ATN_LinkAtn_Title, XDW_ATN_OtherFilePath,
                         XDW_ATN_MailAddress,
                         XDW_ATN_TopField, XDW_ATN_BottomField,
                         )):
                     texttype = XDW_TEXT_UNICODE
                 else:
-                    texttype = XDW_TEXT_UNICODE_IFNECESSARY
+                    texttype = XDW_TEXT_MULTIBYTE
                 XDW_SetAnnotationAttributeW(
                         self.page.doc.handle,
                         self.handle,
                         attrname,
                         XDW_ATYPE_STRING,
                         value,
                         texttype,
```

## Comparing `xdwlib-3.9.6/xdwlib/basedocument.py` & `xdwlib-3.9.7/xdwlib/basedocument.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/binder.py` & `xdwlib-3.9.7/xdwlib/binder.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/bitmap.py` & `xdwlib-3.9.7/xdwlib/bitmap.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/common.py` & `xdwlib-3.9.7/xdwlib/common.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/document.py` & `xdwlib-3.9.7/xdwlib/document.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/documentinbinder.py` & `xdwlib-3.9.7/xdwlib/documentinbinder.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/observer.py` & `xdwlib-3.9.7/xdwlib/observer.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/page.py` & `xdwlib-3.9.7/xdwlib/page.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/struct.py` & `xdwlib-3.9.7/xdwlib/struct.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/timezone.py` & `xdwlib-3.9.7/xdwlib/timezone.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/xdwapi.py` & `xdwlib-3.9.7/xdwlib/xdwapi.py`

 * *Files 0% similar despite different names*

```diff
@@ -2387,16 +2387,16 @@
             args.append(NULL)
             size = TRY(getattr(DLL, api.__name__), *args)
             # Pass 2 - read the actual value.
             if attrtype.value in (XDW_ATYPE_INT, XDW_ATYPE_DATE,
                                   XDW_ATYPE_BOOL, XDW_ATYPE_OCTS):
                 attrvalue = c_int()
             elif attrtype.value == XDW_ATYPE_STRING:
-                attrvalue = create_buffer(
-                        multitype and widename or widevalue)(size)
+                wide = bool(widename if multitype else widevalue)
+                attrvalue = create_buffer(wide)(size)
             else:  # if attrtype.value == XDW_ATYPE_OTHER:
                 attrvalue = (XDW_POINT * int(size / sizeof(XDW_POINT)))()
             if widevalue:
                 args[-5:-3] = [byref(attrvalue), size]
             else:
                 args[-3:-1] = [byref(attrvalue), size]
             TRY(getattr(DLL, api.__name__), *args)
```

## Comparing `xdwlib-3.9.6/xdwlib/xdwfile.py` & `xdwlib-3.9.7/xdwlib/xdwfile.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,1175 +1,1177 @@
-#!/usr/bin/env python3
-# vim: set fileencoding=utf-8 fileformat=unix expandtab :
-
-"""xdwfile.py -- DocuWorks-compatible files
-
-Copyright (C) 2010 HAYASHI Hideki <hideki@hayasix.com>  All rights reserved.
-
-This software is subject to the provisions of the Zope Public License,
-Version 2.1 (ZPL). A copy of the ZPL should accompany this distribution.
-THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
-WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
-FOR A PARTICULAR PURPOSE.
-"""
-
-import os
-import datetime
-import shutil
-import atexit
-
-from .xdwapi import *
-from .common import *
-from .struct import Point
-from .timezone import *
-from .observer import *
-
-
-__all__ = (
-        "XDWFile", "PageForm", "AttachmentList", "Attachment",
-        "StampSignature", "PKISignature",
-        "xdwopen", "create_sfx", "extract_sfx", "optimize", "copy",
-        "protection_info", "protect", "unprotect", "sign",
-        "VALID_DOCUMENT_HANDLES",
-        )
-
-
-# The last resort to close documents in interactive session.
-try:
-    VALID_DOCUMENT_HANDLES
-except NameError:
-    VALID_DOCUMENT_HANDLES = []
-
-
-@atexit.register
-def atexithandler():
-    """Close all files and perform finalization before finishing process."""
-    for handle in VALID_DOCUMENT_HANDLES:
-        try:
-            XDW_CloseDocumentHandle(handle)
-        except:
-            continue
-        VALID_DOCUMENT_HANDLES.remove(handle)
-    XDW_Finalize()
-
-
-def view(path, light=False, wait=True, page=0, fullscreen=False, zoom=0):
-    """View document.
-
-    path        (str) open {path}
-    light       (bool) force to use DocuWorks Viewer Light.
-                Note that DocuWorks Viewer is used if Light version is
-                not avaiable.
-    wait        (bool) wait until viewer stops
-    page        (int) page number to view
-    fullscreen  (bool) view in full screen (presentation mode)
-    zoom        (int) in 10-1600 percent; 0 means 100%
-                (str) 'WIDTH' | 'HEIGHT' | 'PAGE'
-    """
-    import subprocess
-    ext = os.path.splitext(path)[1].lower()
-    if ext not in (".xdw", ".xbd", ".xct"):
-        raise BadFormatError("extension must be .xdw, .xbd or .xct")
-    if XDWVER < 8 and ext == ".xct":
-        raise NewFormatError(f".xct is not supported by DocuWorks {XDWVER}")
-    args = [get_viewer(light=light), path]
-    if page:
-        args.append(f"/n{page + 1}")
-    if fullscreen:
-        args.append("/f")
-    if isinstance(zoom, (int, float)) and zoom:
-        if zoom and not (10 <= zoom <= 1600):
-            raise ValueError(f"10..1600(%) is valid, {zoom} given")
-        args.append(f"/m{int(zoom)}")
-    elif isinstance(zoom, str):
-        if zoom.upper() not in ("WIDTH", "HEIGHT", "PAGE"):
-            raise ValueError((f"int, 'WIDTH', 'HEIGHT' or 'PAGE' is valid"
-                              f"for window size, {repr(zoom)} given"))
-        args.append(f"/m{zoom[0].lower()}")
-    elif zoom:
-        raise ValueError(f"10..1600(%) or WIDTH/HEIGHT/PAGE is valid "
-                         f"for zoom, {zoom} given")
-    proc = subprocess.Popen(args)
-    if not wait:
-        return (proc, path)
-    proc.wait()
-
-
-def xdwopen(path, readonly=False, authenticate=True, autosave=False):
-    """General opener.
-
-    Returns Document or Binder object.
-    """
-    from .document import Document, Container
-    from .binder import Binder
-    if XDWVER < 8:
-        XDW_TYPES = {".xdw": Document, ".xbd": Binder}
-    else:
-        XDW_TYPES = {".xdw": Document, ".xbd": Binder, ".xct": Container}
-    ext = os.path.splitext(path)[1].lower()
-    if ext not in XDW_TYPES:
-        raise BadFormatError("extension must be .xdw, .xbd, or .xct")
-    doc = XDW_TYPES[ext](path)
-    doc.open(readonly=readonly, authenticate=authenticate, autosave=autosave)
-    return doc
-
-
-def create_sfx(input_path, output_path=None):
-    """Create self-extract executable file.
-
-    Returns pathname of generated sfx executable file.
-    """
-    input_path = adjust_path(input_path)
-    root, ext = os.path.splitext(input_path)
-    output_path = adjust_path(output_path or root, ext=".exe")
-    output_path = derivative_path(output_path)
-    if XDWVER < 8:
-        XDW_CreateSfxDocument(cp(input_path), cp(output_path))
-    elif XDWVER < 9:
-        XDW_CreateSfxDocumentW(input_path, output_path)
-    else:
-        raise NotImplementedError
-    return output_path
-
-
-def extract_sfx(input_path, output_path=None):
-    """Extract DocuWorks document/binder from self-extract executable file.
-
-    Returns pathname of generated document/binder file.
-    """
-    input_path = adjust_path(input_path)
-    root, ext = os.path.splitext(input_path)
-    output_path = adjust_path(output_path or root, ext=".xdw")
-    output_path = derivative_path(output_path)
-    if XDWVER < 8:
-        XDW_ExtractFromSfxDocument(cp(input_path), cp(output_path))
-    else:
-        XDW_ExtractFromSfxDocumentW(input_path, output_path)
-    # Created file can be either document or binder.  We have to examine
-    # which type of file was generated and rename if needed.
-    doc = xdwopen(output_path, readonly=True)
-    doctype = doc.type
-    doc.close()
-    if doctype == XDW_DT_DOCUMENT:
-        return output_path
-    # Binder
-    binder_path = derivative_path(os.path.splitext(output_path)[0] + ".xbd")
-    os.rename(output_path, binder_path)
-    return binder_path
-
-
-def optimize(input_path, output_path=None):
-    """Optimize document/binder file.
-
-    Returns the created pathname which may differ from output_path.
-    """
-    input_path = adjust_path(input_path)
-    root, ext = os.path.splitext(input_path)
-    output_path = adjust_path(output_path or root, ext=ext)
-    output_path = derivative_path(output_path)
-    if XDWVER < 8:
-        XDW_OptimizeDocument(cp(input_path), cp(output_path))
-    else:
-        XDW_OptimizeDocumentW(input_path, output_path)
-    return output_path
-
-
-def copy(input_path, output_path=None):
-    """Copy DocuWorks document/binder to another one.
-
-    Returns the created pathname which may differ from output_path.
-    """
-    input_path = adjust_path(input_path)
-    root, ext = os.path.splitext(input_path)
-    output_path = adjust_path(output_path or root, ext=ext)
-    output_path = derivative_path(output_path)
-    shutil.copyfile(input_path, output_path)
-    return output_path
-
-
-def protection_info(path):
-    """Get protection information on a document/binder.
-
-    Returns None if path points a container, or (protect_type, permission)
-    where:
-    protect_type    'PASSWORD' | 'PASSWORD128' | 'PKI' | 'STAMP' |
-                    'CONTEXT_SERVICE'
-    permission      allowed operation(s); comma separated list of
-                    'EDIT_DOCUMENT', 'EDIT_ANNOTATION', 'PRINT' and 'COPY'
-    """
-    path = adjust_path(path)
-    ext = os.path.splitext(path)[1].lower()
-    if ext == ".xct":
-        return None
-    if XDWVER < 8:
-        info = XDW_GetProtectionInformation(cp(path))
-    else:
-        info = XDW_GetProtectionInformationW(path)
-    protect_type = XDW_PROTECT[info.nProtectType]
-    permission = flagvalue(XDW_PERM, info.nPermission, store=False)
-    return (protect_type, permission)
-
-
-def protect(input_path,
-        output_path=None,
-        protect_type="PASSWORD",
-        auth="NONE",
-        **options):
-    """Generate protected document/binder.
-
-    protect_type    'PASSWORD' | 'PASSWORD128' | 'PKI'
-                               | 'PASSWORD256' | | 'PKI256'  -- DW 8+
-    auth            'NONE' | 'NODIALOGUE' | 'CONDITIONAL'
-
-    **options for PASSWORD and PASSWORD128:
-    permission      allowed operation(s); comma separated list of
-                    'EDIT_DOCUMENT', 'EDIT_ANNOTATION', 'PRINT' and 'COPY'
-    password        password to open document/binder, or None
-    fullaccess      password to open document/binder with full-access
-                    privilege, or None
-    comment         notice in password dialogue, or None
-
-    **options for PKI:
-    permission      allowed operation(s); comma separated list of
-                    'EDIT_DOCUMENT', 'EDIT_ANNOTATION', 'PRINT' and 'COPY'
-    certificates    list of certificates in DER (RFC3280) formatted str
-    fullaccesscerts list of certificates in DER (RFC3280) formatted str
-
-    Returns the created pathname which may differ from output_path.
-    """
-    input_path = adjust_path(input_path)
-    root, ext = os.path.splitext(input_path)
-    output_path = adjust_path(output_path or root, ext=ext)
-    output_path = derivative_path(output_path)
-    protect_option = XDW_PROTECT_OPTION()
-    protect_option.nAuthMode = XDW_AUTH.normalize(auth)
-    protect_type = XDW_PROTECT.normalize(protect_type)
-    o = lambda s: options.get(s)
-    if protect_type in (XDW_PROTECT_PSWD, XDW_PROTECT_PSWD128, XDW_PROTECT_256):
-        opt = XDW_SECURITY_OPTION_PSWD()
-        opt.nPermission = flagvalue(XDW_PERM, o("permission"), store=True)
-        opt.szOpenPswd = o("password") or ""
-        opt.szFullAccessPswd = o("fullaccess") or ""
-        opt.lpszComment = o("comment") or ""
-    elif protect_type in (XDW_PROTECT_PKI, XDW_PROTECT_PKI256):
-        opt = XDW_SECURITY_OPTION_PKI()
-        opt.nPermission = flagvalue(XDW_PERM, o("permission"), store=True)
-        certificates = o("certificates")
-        if not certificates:
-            raise ValueError("a list of certificate(s) is required")
-        fullaccesscerts = o("fullacccesscerts")
-        opt.nCertsNum = len(certificates) + len(fullaccesscerts)
-        opt.nFullAccessCertsNum = len(fullaccesscerts)
-        certs = fullaccesscerts + certificates
-        ders = (XDW_DER_CERTIFICATE * opt.nCertsNum)()
-        for i in range(opt.nCertsNum):
-            ders[i].pCert = pointer(certs[i])
-            ders[i].nCertSize = len(certs[i])
-        opt.lpxdcCerts = byref(ders)
-    elif protect_type in (XDW_PROTECT_STAMP, XDW_PROTECT_CONTEXT_SERVICE):
-        raise NotImplementedError(
-                "only password- or PKI-based protection is available")
-    else:
-        raise ValueError("protect_type must be PASSWORD, PASSWORD128 or PKI")
-    try:
-        if XDWVER < 8:
-            XDW_ProtectDocument(cp(input_path), cp(output_path),
-                    protect_type, opt, protect_option)
-        else:
-            XDW_ProtectDocumentW(input_path, output_path,
-                    protect_type, opt, protect_option)
-    except ProtectModuleError as e:
-        msg = XDW_SECURITY_PKI_ERROR[opt.nErrorStatus]
-        if 0 <= opt.nFirstErrorCert:
-            msg += " in cert[%d]" % opt.nFirstErrorCert
-        raise ProtectModuleError(msg)
-    return output_path
-
-
-def unprotect(input_path, output_path=None, auth="NONE"):
-    """Release protection on document/binder.
-
-    auth            'NODIALOGUE' | 'CONDITIONAL'
-
-    Returns the created pathname which may differ from output_path.
-
-    NB. Only PKI-based or DocuWorks-builtin-stamp-based protected files are
-        processed.  Password-based protected files are beyond xdwlib.
-    """
-    input_path = adjust_path(input_path)
-    root, ext = os.path.splitext(input_path)
-    output_path = adjust_path(output_path or root, ext=ext)
-    output_path = derivative_path(output_path)
-    if protection_info(input_path)[0] not in ("PKI", "STAMP"):
-        raise ValueError("only PKI- or STAMP-protected file is acceptable")
-    auth = XDW_AUTH.normalize(auth)
-    if auth not in (XDW_AUTH_NODIALOGUE, XDW_AUTH_CONDITIONAL_DIALOGUE):
-        raise ValueError("auth must be NODIALOGUE or CONDITIONAL")
-    opt = XDW_RELEASE_PROTECTION_OPTION()
-    opt.nAuthMode = auth
-    if XDWVER < 8:
-        XDW_ReleaseProtectionOfDocument(cp(input_path), cp(output_path), opt)
-    else:
-        XDW_ReleaseProtectionOfDocumentW(input_path, output_path, opt)
-    return output_path
-
-
-def sign(input_path,
-        output_path=None,
-        page=0,
-        position=None,
-        type="STAMP",
-        certificate=None):
-    """Sign i.e. place a signature on document/binder page.
-
-    page            page number to paste signature on; starts with 0
-    position        (Point) position to paste signature on; default=(0, 0)
-    type            'STAMP' | 'PKI'
-    certificate     certificate in DER (RFC3280) formatted str; valid for PKI
-
-    Returns the created pathname which may differ from output_path.
-    """
-    input_path = adjust_path(input_path)
-    root, ext = os.path.splitext(input_path)
-    output_path = adjust_path(output_path or root, ext=ext)
-    output_path = derivative_path(output_path)
-    opt = XDW_SIGNATURE_OPTION_V5()
-    opt.nPage = page + 1
-    opt.nHorPos, opt.nVerPos = ((position or Point(0, 0)) * 100).int()
-    opt.nSignatureType = XDW_SIGNATURE.normalize(type)
-    type = XDW_SIGNATURE.normalize(type)
-    if type == XDW_SIGNATURE_STAMP:
-        modopt = None
-    else:  # opt.nSignatureType == XDW_SIGNATURE_PKI
-        modopt = XDW_SIGNATURE_MODULE_OPTION_PKI()
-        modopt.pSignerCert = ptr(cert)
-        modopt.nSignerCertSize = len(cert)
-    if XDWVER < 8:
-        XDW_SignDocument(cp(input_path), cp(output_path), opt, modopt)
-    else:
-        XDW_SignDocumentW(input_path, output_path, opt, modopt)
-    return output_path
-
-
-class AttachmentList(Subject):
-
-    """Collection of Attachments aka original data."""
-
-    def __init__(self, doc, size=None):
-        Subject.__init__(self)
-        self.doc = doc
-        if size:
-            self.size = size
-        else:
-            docinfo = XDW_GetDocumentInformation(doc.handle)
-            self.size = docinfo.nOriginalData
-
-    def __len__(self):
-        return self.size
-
-    def __iter__(self):
-        for pos in range(self.size):
-            yield self.attachment(pos)
-
-    def _pos(self, pos, append=False):
-        append = 1 if append else 0
-        if not (-self.size <= pos < self.size + append):
-            raise IndexError("Attachment #{0} not in [{1}, {2})".format(
-                    pos, -self.size, self.size + append))
-        if pos < 0:
-            pos += self.size
-        return pos
-
-    def attachment(self, pos):
-        """Get an attachment, aka original data."""
-        pos = self._pos(pos)
-        if pos not in self.observers:
-            self.observers[pos] = Attachment(self.doc, pos)
-        return self.observers[pos]
-
-    def __getitem__(self, pos):
-        return self.attachment(pos)
-
-    def append(self, path):
-        """Append an attachment, aka original data, at the end of XDW/XBD."""
-        return self.insert(self.size, path)
-
-    def insert(self, pos, path):
-        """Insert an attachment, aka original data.
-
-        pos     position to insert; starts with 0
-        path    pathname of a file to insert
-        """
-        pos = self._pos(pos, append=True)
-        XDW_InsertOriginalData(self.doc.handle, pos + 1, cp(path))
-        self.size += 1
-        att = self.attachment(pos)
-        self.attach(att, EV_ATT_INSERTED)
-
-    def delete(self, pos):
-        """Remove an attachment, aka original data."""
-        pos = self._pos(pos)
-        att = self.attachment(pos)
-        XDW_DeleteOriginalData(self.doc.handle, pos + 1)
-        self.detach(att, EV_ATT_REMOVED)
-        self.size -= 1
-
-    def __delitem__(self, pos):
-        self.delete(pos)
-
-
-class Attachment(Observer):
-
-    """Place holder for attachments aka original data."""
-
-    def __init__(self, doc, pos):
-        self.doc = doc
-        self.pos = pos
-        info, text_type = XDW_GetOriginalDataInformationW(
-                doc.handle, pos + 1, codepage=CP)
-        self.text_type = XDW_TEXT_TYPE[text_type]
-        self.size = info.nDataSize
-        self.datetime = fromunixtime(info.nDate)
-        self.name = info.szName
-
-    def name_compat(self, encoding, errors="ignore"):
-        info = XDW_GetOriginalDataInformation(
-                self.doc.handle, self.pos + 1)
-        return info.szName.decode(encoding, errors=errors)
-
-    def update(self, event):
-        """Update self as an observer."""
-        if not isinstance(event, Notification):
-            raise TypeError("not an instance of Notification class")
-        if event.type == EV_ATT_REMOVED:
-            if event.para[0] < self.pos:
-                self.pos -= 1
-        elif event.type == EV_ATT_INSERTED:
-            if event.para[0] < self.pos:
-                self.pos += 1
-        else:
-            raise ValueError(f"Illegal event type: {event.type}")
-
-    def save(self, path=None):
-        """Save attached file.
-
-        path    (str) save to {path};
-                      with no dir, save to {document/binder dir}/{path}
-                (None) save to {document/binder dir}/{stored filename}
-
-        Returns the saved pathname which may differ from path.
-        """
-        path = newpath(path or self.name, dir=self.doc.dirname())
-        if XDWVER < 8:
-            XDW_GetOriginalData(self.doc.handle, self.pos + 1, cp(path))
-        else:
-            XDW_GetOriginalDataW(self.doc.handle, self.pos + 1, path)
-        return path
-
-
-class XDWFile(object):
-
-    """Docuworks file XDW, XBD and XCT."""
-
-    @staticmethod
-    def all_attributes():  # for debugging
-        return [outer_attribute_name(k) for k in XDW_DOCUMENT_ATTRIBUTE_W]
-
-    def register(self):
-        VALID_DOCUMENT_HANDLES.append(self.handle)
-
-    def free(self):
-        VALID_DOCUMENT_HANDLES.remove(self.handle)
-
-    @staticmethod
-    def _free(handle):
-        VALID_DOCUMENT_HANDLES.remove(handle)
-
-    def __init__(self, path):
-        """Initiator.
-
-        Sets the following properties:
-            dir         (str) directory part of path
-            name        (str) filename without extension
-            type        (str) 'DOCUMENT' | 'BINDER' | 'CONTAINER'
-            protection  result of protection_info(path)
-
-        NB. value of `type' may be changed after actual open().
-        """
-        self.properties = None
-        self.signatures = None
-        self.dir, self.name = os.path.split(path)
-        self.name, ext = os.path.splitext(self.name)
-        self.handle = None
-        self.pages = 0
-        self.version = None
-        self.attachments = None
-        types = {"Document": XDW_DT_DOCUMENT, "Binder": XDW_DT_BINDER,
-                 "Container": XDW_DT_CONTAINER}
-        classname = self.__class__.__name__
-        self.type = XDW_DOCUMENT_TYPE[types[classname]]
-        self.editable = True
-        self.annotatable = True
-        self.printable = True
-        self.copyable = True
-        self._show_annotations = True
-        self.status = None
-        self.readonly = False
-        self.authenticate = False
-        self.protection = protection_info(path)
-
-    def open(self, readonly=False, authenticate=True, autosave=False):
-        """Opener."""
-        self._autosave = bool(autosave)
-        open_mode = XDW_OPEN_MODE_EX()
-        if readonly:
-            open_mode.nOption = XDW_OPEN_READONLY
-        else:
-            open_mode.nOption = XDW_OPEN_UPDATE
-        if authenticate:
-            open_mode.nAuthMode = XDW_AUTH_NODIALOGUE
-        else:
-            open_mode.nAuthMode = XDW_AUTH_NONE
-        if XDWVER < 8:
-            self.handle = XDW_OpenDocumentHandle(cp(self.pathname()), open_mode)
-        else:
-            self.handle = XDW_OpenDocumentHandleExW(self.pathname(), open_mode)
-        self.register()
-        # Set document properties.
-        docinfo = XDW_GetDocumentInformation(self.handle)
-        self.pages = docinfo.nPages
-        self.version = docinfo.nVersion - 3  # DocuWorks version
-        self.attachments = AttachmentList(self, size=docinfo.nOriginalData)
-        self.type = XDW_DOCUMENT_TYPE[docinfo.nDocType]
-        self.editable = bool(docinfo.nPermission & XDW_PERM_DOC_EDIT)
-        self.annotatable = bool(docinfo.nPermission & XDW_PERM_ANNO_EDIT)
-        self.printable = bool(docinfo.nPermission & XDW_PERM_PRINT)
-        self.copyable = bool(docinfo.nPermission & XDW_PERM_COPY)
-        self._show_annotations = bool(docinfo.nShowAnnotations)
-        # Followings are effective only for binders.
-        self.documents = docinfo.nDocuments
-        self.binder_color = XDW_BINDER_COLOR[docinfo.nBinderColor]
-        self.binder_size = XDW_BINDER_SIZE[docinfo.nBinderSize]
-        # Document attributes.
-        self._set_property_count()
-        # Attached signatures.
-        self._set_signature_count()
-        # Document verification status.
-        self.status = None
-        # Remember arguments for future use.
-        self.readonly = readonly
-        self.authenticate = authenticate
-        return self
-
-    def _set_property_count(self):
-        self.properties = XDW_GetDocumentAttributeNumber(self.handle)
-
-    def _set_signature_count(self):
-        self.signatures = XDW_GetDocumentSignatureNumber(self.handle)
-
-    def filename(self):
-        """Get filename with extension."""
-        exts = {"DOCUMENT": ".xdw", "BINDER": ".xbd", "CONTAINER": ".xct"}
-        return self.name + exts[self.type]
-
-    def pathname(self):
-        """Get full pathname with extension."""
-        return os.path.join(self.dir, self.filename())
-
-    def update_pages(self):
-        """Update number of pages; used after insert multiple pages in."""
-        docinfo = XDW_GetDocumentInformation(self.handle)
-        self.pages = docinfo.nPages
-
-    def save(self):
-        """Save document regardless of whether it is modified or not."""
-        XDW_SaveDocument(self.handle)
-
-    def close(self):
-        """Close document."""
-        if not self.handle:
-            return
-        if self._autosave:
-            self.save()
-        XDW_CloseDocumentHandle(self.handle)
-        self.free()
-        self.handle = None
-
-    @staticmethod
-    def _close(handle):
-        XDW_CloseDocumentHandle(handle)
-        XDWFile._free(handle)
-
-    @property
-    def show_annotations(self):
-        return self._show_annotations
-
-    @show_annotations.setter
-    def show_annotations(self, value):
-        value = bool(value)
-        XDW_ShowOrHideAnnotations(self.handle, value)
-        self._show_annotations = value
-        return
-
-    def __getattribute__(self, name):
-        attribute_name = inner_attribute_name(name)
-        if attribute_name not in XDW_DOCUMENT_ATTRIBUTE_W:
-            self_signatures = object.__getattribute__(self, "signatures")
-            if name == "status" and self_signatures:
-                self_signature = object.__getattribute__(self, "signature")
-                self_signature(0)  # Update document verification status.
-            return object.__getattribute__(self, name)
-        self_handle = object.__getattribute__(self, "handle")
-        t, value, _ = XDW_GetDocumentAttributeByNameW(
-                self_handle, attribute_name, codepage=CP)
-        return makevalue(t, value)
-
-    def __setattr__(self, name, value):
-        attribute_name = inner_attribute_name(name)
-        if attribute_name in XDW_DOCUMENT_ATTRIBUTE_W:
-            t, value = typevalue(value)
-            XDW_SetDocumentAttributeW(self.handle, attribute_name, t, value,
-                    XDW_TEXT_UNICODE_IFNECESSARY, codepage=CP)
-            return
-        object.__setattr__(self, name, value)
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.close()
-
-    def get_userattr(self, name, default=None):
-        """Get user defined attribute.
-
-        name        (str or bytes) attribute name in OEM encoding
-        default     value to return if no attribute named name exist
-        """
-        try:
-            if XDWVER < 8:
-                return XDW_GetUserAttribute(self.handle, cp(name))
-            else:
-                return XDW_GetUserAttributeW(self.handle, name)
-        except InvalidArgError:
-            return default
-
-    def set_userattr(self, name, value):
-        """Set user defined attribute.
-
-        name        (str or bytes) attribute name in OEM encoding
-        value       (str or bytes) attribute value in OEM encoding
-        """
-        if XDWVER < 8:
-            XDW_SetUserAttribute(self.handle, cp(name), value)
-        else:
-            XDW_SetUserAttributeW(self.handle, name, value)
-
-    def has_property(self, name):
-        """Test if user defined property exists.
-
-        name        (str) name of property
-
-        Returns True if such property exists, or False if not.
-        """
-        if not isinstance(name, str):
-            raise TypeError("property name must be str")
-        try:
-            t, value, _ = XDW_GetDocumentAttributeByNameW(
-                    self.handle, name, codepage=CP)
-        except InvalidArgError:
-            return False
-        return True
-
-    def get_property(self, name, default=None):
-        """Get user defined property.
-
-        name        (str) name of property, or user attribute
-                    (int) property order which starts with 0
-        default     value to return if no property named name exist
-
-        Returns a str, int, bool or datetime.date.
-
-        Note that previous set_property(bytes_value) gives str (i.e., unicode).
-        """
-        if isinstance(name, str):
-            try:
-                t, value, _ = XDW_GetDocumentAttributeByNameW(
-                        self.handle, name, codepage=CP)
-            except InvalidArgError:
-                return default
-        elif isinstance(name, int):
-            n = self.properties
-            if name < 0:
-                name += n
-            if not( 0 <= name < n):
-                raise IndexError("attribute order out of range [0, %d)" % n)
-            name, t, value, _ = XDW_GetDocumentAttributeByOrderW(
-                                            self.handle, name + 1)
-            return (name, makevalue(t, value))
-        else:
-            raise TypeError("name must be str or int")
-        return makevalue(t, value)
-
-    def set_property(self, name, value, update=True):
-        """Set user defined property.
-
-        name        (str) name of property, or user attribute
-        value       (str, bytes, int, bool or datetime.date) stored value
-                    (None) delete property if update==False
-        update      (bool) False=don't update value if exists already
-
-        Note that bytes value is actually stored in unicode and get_property()
-        will returen str (i.e., unicode str).
-        """
-        if not update and self.get_property(name) is not None:
-            return
-        if value is None:
-            self.del_property(name)
-            return
-        if isinstance(value, bytes):
-            value = uc(value)  # Force to store in unicode.
-        t, value = typevalue(value)
-        if t != XDW_ATYPE_STRING:
-            value = byref(value)
-        XDW_SetDocumentAttributeW(self.handle, name, t, value,
-                XDW_TEXT_UNICODE_IFNECESSARY, codepage=CP)
-        self._set_property_count()
-
-    def del_property(self, name):
-        """Delete user defined property.
-
-        name        (str) name of property, or user attribute
-        """
-        XDW_SetDocumentAttributeW(self.handle, name, XDW_ATYPE_INT, NULL,
-                XDW_TEXT_UNICODE_IFNECESSARY, codepage=CP)
-        self._set_property_count()
-
-    hasprop = has_property
-    getprop = get_property
-    setprop = set_property
-    delprop = del_property
-
-    def pageform(self, form):
-        return PageForm(self, form)
-
-    def pageform_text(self):
-        """Get all text in page form."""
-        return ASEP.join(self.pageform(form).text
-                for form in ("header", "footer"))
-
-    def update_pageform(self, sync=False):
-        """Update page form.
-
-        sync        (bool) also update pageforms for documents in binder
-        """
-        sync = XDW_PAGEFORM_REMOVE if sync else XDW_PAGEFORM_STAY
-        XDW_UpdatePageForm(self.handle, sync)
-
-    def delete_pageform(self, sync=False):
-        """Delete page form.
-
-        sync        (bool) also delete pageforms for documents in binder
-        """
-        sync = XDW_PAGEFORM_REMOVE if sync else XDW_PAGEFORM_STAY
-        XDW_RemovePageForm(self.handle, sync)
-
-    updform = update_pageform
-    delform = delete_pageform
-
-    def signature(self, pos):
-        """Get signature information.
-
-        Returns StampSignature or PKISignature object.
-        """
-        siginfo, modinfo = XDW_GetSignatureInformation(self.handle, pos + 1)
-        if siginfo.nSignatureType == XDW_SIGNATURE_STAMP:
-            sts = XDW_SIGNATURE_STAMP_STAMP[modinfo.nStampVerificationStatus]
-            docsts = XDW_SIGNATURE_STAMP_DOC[modinfo.nDocVerificationStatus]
-            sig = StampSignature(
-                    self,
-                    pos,
-                    siginfo.nPage - 1,
-                    Point(siginfo.nHorPos, siginfo.nVerPos) / 100.0,
-                    Point(siginfo.nWidth, siginfo.nHeight) / 100.0,
-                    fromunixtime(siginfo.nSignedTime),
-                    stamp_name=modinfo.lpszStampName,
-                    owner_name=modinfo.lpszOwnerName,
-                    valid_until=fromunixtime(modinfo.nValidDate),
-                    memo=modinfo.lpszRemarks,
-                    status=sts,
-                    )
-            self.status = docsts
-        else:  # siginfo.nSignatureType == XDW_SIGNATURE_PKI
-
-            def parsedt(s):
-                return datetime.datetime.strptime(s.decode("ascii"),
-                                                  "%Y/%m/%d %H:%M:%S")
-
-            ver = XDW_SIGNATURE_PKI_TYPE[modinfo.nCertVerificationType]
-            sts = XDW_SIGNATURE_PKI_CERT[modinfo.nCertVerificationStatus]
-            docsts = XDW_SIGNATURE_PKI_DOC[modinfo.nDocVerificationStatus]
-            sig = PKISignature(
-                    self,
-                    pos,
-                    siginfo.nPage - 1,
-                    Point(siginfo.nHorPos, siginfo.nVerPos) / 100.0,
-                    Point(siginfo.nWidth, siginfo.nHeight) / 100.0,
-                    fromunixtime(siginfo.nSignedTime),
-                    module=modinfo.lpszModule,
-                    subjectdn=modinfo.lpszSubjectDN,
-                    subject=modinfo.lpszSubject,
-                    issuerdn=modinfo.lpszIssuerDN,
-                    issuer=modinfo.lpszIssuer,
-                    not_before=parsedt(modinfo.lpszNotBefore),
-                    not_after=parsedt(modinfo.lpszNotAfter),
-                    serial=modinfo.lpszSerial,
-                    certificate=modinfo.signer_cert,
-                    memo=modinfo.lpszRemarks,
-                    signing_time=parsedt(modinfo.lpszSigningTime),
-                    verification_type=ver,
-                    status=sts,
-                    )
-            self.status = docsts
-        return sig
-
-    def _process(self, meth, *args, **kw):
-        selfpath = self.pathname()
-        oldhandle = self.handle
-        if oldhandle:
-            self.save()
-            self.close()
-        new_selfpath = meth(selfpath, *args, **kw)
-        if kw.get("output_path"):
-            if oldhandle:
-                self.open(readonly=self.readonly,
-                        authenticate=self.authenticate,
-                        autosave=self._autosave)
-            return new_selfpath
-        # Swap the old for the new, and remove the old.
-        os.remove(selfpath)
-        os.rename(new_selfpath, selfpath)
-        if oldhandle:
-            self.open(readonly=self.readonly,
-                    authenticate=self.authenticate,
-                    autosave=self._autosave)
-            # Renew related attributes.
-            self.signatures = XDW_GetDocumentSignatureNumber(self.handle)
-            self.status = None
-
-    def sign(self,
-            output_path=None,
-            page=0,
-            position=None,
-            type="STAMP",
-            certificate=None):
-        """Sign i.e. attach signature.
-
-        See xdwfile.sign() for arguments.
-
-        Returns the created pathname which may differ from output_path,
-        if called with output_path specified.
-
-        NB. self.save() is performed internally.
-        """
-        return self._process(sign, output_path=output_path, page=page,
-                position=position, type=type, certificate=certificate)
-
-    def protect(self,
-            output_path=None,
-            protect_type="PASSWORD",
-            auth="NONE",
-            **options):
-        """Protect document/binder.
-
-        See xdwfile.protect() for arguments.
-
-        Returns the created pathname which may differ from output_path,
-        if called with output_path specified.
-
-        NB. Only password- or PKI-based protection is available.
-        NB. self.save() is performed internally.
-        """
-        return self._process(protect, output_path=output_path,
-                protect_type=protect_type, auth=auth, **options)
-
-    def unprotect(self, output_path=None, auth="NONE"):
-        """Release protection on document/binder.
-
-        See xdwfile.unprotect() for arguments.
-
-        Returns the created pathname which may differ from output_path,
-        if called with output_path specified.
-
-        NB. Only PKI- or STAMP-protected file is acceptable.
-        NB. self.save() is performed internally.
-        """
-        return self._process(unprotect, output_path=output_path, auth=auth)
-
-    def optimize(self, output_path=None):
-        """Optimize document/binder file.
-
-        See xdwfile.optimize() for arguments.
-
-        Returns the created pathname which may differ from output_path,
-        if called with output_path specified.
-
-        NB. self.save() is performed internally.
-        """
-        return self._process(optimize, output_path=output_path)
-
-
-class BaseSignature(object):
-
-    """Base class for StampSignature and PKISignature."""
-
-    def __init__(self, doc, pos, pagepos, position, size, dt):
-        """Initiator.
-
-        doc             Document/Binder
-        pos             position in signature list of doc; starts with 0
-        pagepos         page number to paste signature on; starts with 0
-        position        (Point) position in mm to paste signature on
-        size            (Point) size in mm to show signature
-        dt              (datetime.datetime) signed datetime
-        """
-        self.doc = doc
-        self.pos = pos
-        self.pagepos = pagepos
-        self.position = position
-        self.size = size
-        self.dt = dt
-
-    def __repr__(self):
-        return  "{cls}({doc}[{pos}])".format(
-                cls=self.__class__.__name__,
-                doc=self.doc.name,
-                pos=self.pos,
-                )
-
-    def __str__(self):
-        return  "{cls}({doc}[{pos}]; page {pgpos}, position {loc}mm)".format(
-                cls=self.__class__.__name__,
-                doc=self.doc.name,
-                pos=self.pos,
-                pgpos=self.pagepos,
-                loc="({0:.2f}, {1:.2f})".format(*self.position),
-                )
-
-    def update(self):
-        """Update signature status.
-
-        Returns (signature_type, error_status).
-
-        N.B. self.doc.status may be altered.
-        """
-        status = XDW_UpdateSignatureStatus(self.doc.handle, self.pos + 1)
-        return (XDW_SIGNATURE[status.nSignatureType],
-                {
-                    XDW_SIGNATURE_STAMP: XDW_SIGNATURE_STAMP_ERROR,
-                    XDW_SIGNATURE_PKI: XDW_SIGNATURE_PKI_ERROR,
-                }[status.nSignatureType][status.nErrorStatus])
-
-
-class StampSignature(BaseSignature):
-
-    """DocuWorks' built-in stamp signature."""
-
-    def __init__(self, doc, pos, pagepos, position, size, dt,
-            stamp_name="",
-            owner_name="",
-            valid_until=None,
-            memo="",
-            status=None,
-            ):
-        """Initiator.
-
-        doc             Document/Binder
-        pos             position in signature list of doc; starts with 0
-        pagepos         page number to paste signature on; starts with 0
-        position        (Point) position to paste signature on
-        size            (Point) size to show signature
-        dt              (datetime.datetime) signed datetime
-        stamp_name      stamp's name
-        owner_name      owner's name
-        valid_until     (datetime.datetime) ending time of validity
-        memo            (str)
-        status          "NONE" | "TRUSTED" | "NOTRUST"
-        """
-        BaseSignature.__init__(self, doc, pos, pagepos, position, size, dt)
-        self.stamp_name = stamp_name
-        self.owner_name = owner_name
-        self.valid_until = valid_until
-        self.memo = memo
-        self.status = status
-
-
-class PKISignature(BaseSignature):
-
-    """PKI-based signature."""
-
-    def __init__(self, doc, pos, pagepos, position, size, dt,
-            module="",
-            subjectdn="",
-            subject="",
-            issuerdn="",
-            issuer="",
-            not_before=None,
-            not_after=None,
-            serial=None,
-            certificate=None,
-            memo="",
-            signing_time=None,
-            verification_type=None,
-            status=None,
-            ):
-        """Initiator.
-
-        doc             Document/Binder
-        pos             position in signature list of doc; starts with 0
-        pagepos         page number to paste signature on; starts with 0
-        position        (Point) position to paste signature on
-        size            (Point) size to show signature
-        dt              (datetime.datetime) signed datetime
-        module          security module name
-        subjectdn       content of SUBJECT DN (distinguished name);
-                        max. 511 bytes
-        subject         content of SUBJECT; CN, OU, O or E
-        issuerdn        content of ISSUER DN (distinguished name);
-                        max. 511 bytes
-        issuer          content of ISSUER; CN, OU, O or E
-        not_before      (datetime.datetime)
-        not_after       (datetime.datetime)
-        serial          (str)
-        certificate     (str) content of singer certificate in DER (RFC3280)
-                        format
-        memo            (str)
-        signing_time    (datetime.datetime)
-        verification_type   'LOW' | 'MID_LOCAL' | 'MID_NETWORK' |
-                            'HIGH_LOCAL' | 'HIGH_NETWORK'
-        status          'UNKNOWN' | 'OK' | 'NO_ROOT_CERTIFICATE' |
-                        'NO_REVOCATION_CHECK' | OUT_OF_VALIDITY' |
-                        'OUT_OF_VALIDITY_AT_SIGNED_TIME |
-                        'REVOKE_CERTIFICATE' |
-                        'REVOKE_INTERMEDIATE_CERTIFICATE' |
-                        'INVLIAD_SIGNATURE' | 'INVALID_USAGE' |
-                        'UNDEFINED_ERROR'
-        """
-        BaseSignature.__init__(self, doc, pos, pagepos, position, size, dt)
-        self.module = module
-        self.subjectdn = subjectdn[:511]  # max. 511 bytes
-        self.subject = subject  # CN, OU, O or E
-        self.issuerdn = issuerdn[:511]  # max. 511 bytes
-        self.issuer = issuer  # CN, OU, O or E
-        self.not_before = not_before
-        self.not_after = not_after
-        self.serial = serial
-        self.certificate = certificate
-        self.memo = memo
-        self.signing_time = signing_time
-        self.verification_type = verification_type
-        self.status = status
-
-
-class PageForm(object):
-
-    """Header/footer of document."""
-
-    @staticmethod
-    def all_types():
-        """Return all pageform types for convenience."""
-        return tuple(sorted(XDW_PAGEFORM.values()))
-
-    @staticmethod
-    def all_attributes():
-        """Return all pageform attributes for convenience."""
-        return tuple(sorted(
-                "alignment back_color beginning_page digit doc ending_page "
-                "font_char_set font_name font_pitch_and_family font_size "
-                "font_style fore_color form image_file left_right_margin "
-                "page_range starting_number text top_bottom_margin "
-                "ver_position zoom".split()))
-
-    @staticmethod
-    def all_colors():
-        """Returns all colors available."""
-        return tuple(sorted(XDW_COLOR.values()))
-
-    def __init__(self, doc, form):
-        self.__dict__["doc"] = doc
-        self.__dict__["form"] = XDW_PAGEFORM.normalize(form)
-
-    def __repr__(self):
-        return "{cls}({doc}.{attr})".format(
-                cls=self.__class__.__name__,
-                doc=self.doc,
-                attr=outer_attribute_name(XDW_PAGEFORM[self.form]))
-
-    @property
-    def form(self):
-        return self.__dict__["form"]
-
-    @form.setter
-    def form(self, value):
-        object.__setattr__(self, "form", XDW_PAGEFORM.normalize(value))
-
-    def __setattr__(self, name, value):
-        attrname = inner_attribute_name(name)
-        if attrname not in XDW_ANNOTATION_ATTRIBUTE:
-            object.__setattr__(self, name, value)
-            return
-        special = isinstance(XDW_ANNOTATION_ATTRIBUTE[attrname][1], XDWConst)
-        if special or isinstance(value, (int, float)):
-            value = int(scale(attrname, value, store=True))
-            if attrname.endswith("Page"):
-                value += 1  # 1-based
-            value = byref(c_int(value))
-            attribute_type = XDW_ATYPE_INT  # TODO: Scaling may be required.
-        elif isinstance(value, (str, bytes)):
-            attribute_type = XDW_ATYPE_STRING
-            """TODO: unicode handling.
-            Currently Author has no idea to take unicode with ord < 256.
-            Python's unicode may have inner representation with 0x00,
-            e.g.  0x41 0x00 0x42 0x00 0x43 0x00 for "ABC".  This results in
-            unexpected string termination e.g. "ABC" -> "A".  So, if the next
-            if-block is not placed, you will get much more but inexact
-            elements in result for abbreviated search string.
-            """
-            value = cp(value)  # TODO: unicode handling
-            if 255 < len(value):
-                raise ValueError("text length must be <= 255")
-        # TODO: XDW_ATYPE_OTHER should also be valid.
-        else:
-            raise TypeError("illegal value " + repr(value))
-        XDW_SetPageFormAttribute(self.doc.handle, self.form,
-                cp(attrname), attribute_type, value)
-
-    def __getattribute__(self, name):
-        attrname = inner_attribute_name(name)
-        if attrname not in XDW_ANNOTATION_ATTRIBUTE:
-            return object.__getattribute__(self, name)
-        self_doc = object.__getattribute__(self, "doc")
-        self_form = object.__getattribute__(self, "form")
-        value = XDW_GetPageFormAttribute(self_doc.handle, self_form, cp(attrname))
-        attribute_type = XDW_ANNOTATION_ATTRIBUTE[attrname][0]
-        if attribute_type == 1:  # string
-            return uc(value)
-        value = unpack(value)
-        if attrname.endswith("Page"):
-            value -= 1  # 0-based
-        return scale(attrname, value, store=False)
-
-    def update(self, sync=False):
-        """Update page form.
-
-        sync    (bool) also update pageforms for documents in binder
-        """
-        sync = XDW_PAGEFORM_REMOVE if sync else XDW_PAGEFORM_STAY
-        XDW_UpdatePageForm(self.doc.handle, sync)
-
-    def delete(self, sync=False):
-        """Delete page form.
-
-        sync    (bool) also delete pageforms for documents in binder
-        """
-        sync = XDW_PAGEFORM_REMOVE if sync else XDW_PAGEFORM_STAY
-        XDW_RemovePageForm(self.doc.handle, sync)
+#!/usr/bin/env python3
+# vim: set fileencoding=utf-8 fileformat=unix expandtab :
+
+"""xdwfile.py -- DocuWorks-compatible files
+
+Copyright (C) 2010 HAYASHI Hideki <hideki@hayasix.com>  All rights reserved.
+
+This software is subject to the provisions of the Zope Public License,
+Version 2.1 (ZPL). A copy of the ZPL should accompany this distribution.
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
+WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
+FOR A PARTICULAR PURPOSE.
+"""
+
+import os
+import datetime
+import shutil
+import atexit
+
+from .xdwapi import *
+from .common import *
+from .struct import Point
+from .timezone import *
+from .observer import *
+
+
+__all__ = (
+        "XDWFile", "PageForm", "AttachmentList", "Attachment",
+        "StampSignature", "PKISignature",
+        "xdwopen", "create_sfx", "extract_sfx", "optimize", "copy",
+        "protection_info", "protect", "unprotect", "sign",
+        "VALID_DOCUMENT_HANDLES",
+        )
+
+
+# The last resort to close documents in interactive session.
+try:
+    VALID_DOCUMENT_HANDLES
+except NameError:
+    VALID_DOCUMENT_HANDLES = []
+
+
+@atexit.register
+def atexithandler():
+    """Close all files and perform finalization before finishing process."""
+    for handle in VALID_DOCUMENT_HANDLES:
+        try:
+            XDW_CloseDocumentHandle(handle)
+        except:
+            continue
+        VALID_DOCUMENT_HANDLES.remove(handle)
+    XDW_Finalize()
+
+
+def view(path, light=False, wait=True, page=0, fullscreen=False, zoom=0):
+    """View document.
+
+    path        (str) open {path}
+    light       (bool) force to use DocuWorks Viewer Light.
+                Note that DocuWorks Viewer is used if Light version is
+                not avaiable.
+    wait        (bool) wait until viewer stops
+    page        (int) page number to view
+    fullscreen  (bool) view in full screen (presentation mode)
+    zoom        (int) in 10-1600 percent; 0 means 100%
+                (str) 'WIDTH' | 'HEIGHT' | 'PAGE'
+    """
+    import subprocess
+    ext = os.path.splitext(path)[1].lower()
+    if ext not in (".xdw", ".xbd", ".xct"):
+        raise BadFormatError("extension must be .xdw, .xbd or .xct")
+    if XDWVER < 8 and ext == ".xct":
+        raise NewFormatError(f".xct is not supported by DocuWorks {XDWVER}")
+    args = [get_viewer(light=light), path]
+    if page:
+        args.append(f"/n{page + 1}")
+    if fullscreen:
+        args.append("/f")
+    if isinstance(zoom, (int, float)) and zoom:
+        if zoom and not (10 <= zoom <= 1600):
+            raise ValueError(f"10..1600(%) is valid, {zoom} given")
+        args.append(f"/m{int(zoom)}")
+    elif isinstance(zoom, str):
+        if zoom.upper() not in ("WIDTH", "HEIGHT", "PAGE"):
+            raise ValueError((f"int, 'WIDTH', 'HEIGHT' or 'PAGE' is valid"
+                              f"for window size, {repr(zoom)} given"))
+        args.append(f"/m{zoom[0].lower()}")
+    elif zoom:
+        raise ValueError(f"10..1600(%) or WIDTH/HEIGHT/PAGE is valid "
+                         f"for zoom, {zoom} given")
+    proc = subprocess.Popen(args)
+    if not wait:
+        return (proc, path)
+    proc.wait()
+
+
+def xdwopen(path, readonly=False, authenticate=True, autosave=False):
+    """General opener.
+
+    Returns Document or Binder object.
+    """
+    from .document import Document, Container
+    from .binder import Binder
+    if XDWVER < 8:
+        XDW_TYPES = {".xdw": Document, ".xbd": Binder}
+    else:
+        XDW_TYPES = {".xdw": Document, ".xbd": Binder, ".xct": Container}
+    ext = os.path.splitext(path)[1].lower()
+    if ext not in XDW_TYPES:
+        raise BadFormatError("extension must be .xdw, .xbd, or .xct")
+    doc = XDW_TYPES[ext](path)
+    doc.open(readonly=readonly, authenticate=authenticate, autosave=autosave)
+    return doc
+
+
+def create_sfx(input_path, output_path=None):
+    """Create self-extract executable file.
+
+    Returns pathname of generated sfx executable file.
+    """
+    input_path = adjust_path(input_path)
+    root, ext = os.path.splitext(input_path)
+    output_path = adjust_path(output_path or root, ext=".exe")
+    output_path = derivative_path(output_path)
+    if XDWVER < 8:
+        XDW_CreateSfxDocument(cp(input_path), cp(output_path))
+    elif XDWVER < 9:
+        XDW_CreateSfxDocumentW(input_path, output_path)
+    else:
+        raise NotImplementedError
+    return output_path
+
+
+def extract_sfx(input_path, output_path=None):
+    """Extract DocuWorks document/binder from self-extract executable file.
+
+    Returns pathname of generated document/binder file.
+    """
+    input_path = adjust_path(input_path)
+    root, ext = os.path.splitext(input_path)
+    output_path = adjust_path(output_path or root, ext=".xdw")
+    output_path = derivative_path(output_path)
+    if XDWVER < 8:
+        XDW_ExtractFromSfxDocument(cp(input_path), cp(output_path))
+    else:
+        XDW_ExtractFromSfxDocumentW(input_path, output_path)
+    # Created file can be either document or binder.  We have to examine
+    # which type of file was generated and rename if needed.
+    doc = xdwopen(output_path, readonly=True)
+    doctype = doc.type
+    doc.close()
+    if doctype == XDW_DT_DOCUMENT:
+        return output_path
+    # Binder
+    binder_path = derivative_path(os.path.splitext(output_path)[0] + ".xbd")
+    os.rename(output_path, binder_path)
+    return binder_path
+
+
+def optimize(input_path, output_path=None):
+    """Optimize document/binder file.
+
+    Returns the created pathname which may differ from output_path.
+    """
+    input_path = adjust_path(input_path)
+    root, ext = os.path.splitext(input_path)
+    output_path = adjust_path(output_path or root, ext=ext)
+    output_path = derivative_path(output_path)
+    if XDWVER < 8:
+        XDW_OptimizeDocument(cp(input_path), cp(output_path))
+    else:
+        XDW_OptimizeDocumentW(input_path, output_path)
+    return output_path
+
+
+def copy(input_path, output_path=None):
+    """Copy DocuWorks document/binder to another one.
+
+    Returns the created pathname which may differ from output_path.
+    """
+    input_path = adjust_path(input_path)
+    root, ext = os.path.splitext(input_path)
+    output_path = adjust_path(output_path or root, ext=ext)
+    output_path = derivative_path(output_path)
+    shutil.copyfile(input_path, output_path)
+    return output_path
+
+
+def protection_info(path):
+    """Get protection information on a document/binder.
+
+    Returns None if path points a container, or (protect_type, permission)
+    where:
+    protect_type    'PASSWORD' | 'PASSWORD128' | 'PKI' | 'STAMP' |
+                    'CONTEXT_SERVICE'
+    permission      allowed operation(s); comma separated list of
+                    'EDIT_DOCUMENT', 'EDIT_ANNOTATION', 'PRINT' and 'COPY'
+    """
+    path = adjust_path(path)
+    ext = os.path.splitext(path)[1].lower()
+    if ext == ".xct":
+        return None
+    if XDWVER < 8:
+        info = XDW_GetProtectionInformation(cp(path))
+    else:
+        info = XDW_GetProtectionInformationW(path)
+    protect_type = XDW_PROTECT[info.nProtectType]
+    permission = flagvalue(XDW_PERM, info.nPermission, store=False)
+    return (protect_type, permission)
+
+
+def protect(input_path,
+        output_path=None,
+        protect_type="PASSWORD",
+        auth="NONE",
+        **options):
+    """Generate protected document/binder.
+
+    protect_type    'PASSWORD' | 'PASSWORD128' | 'PKI'
+                               | 'PASSWORD256' | | 'PKI256'  -- DW 8+
+    auth            'NONE' | 'NODIALOGUE' | 'CONDITIONAL'
+
+    **options for PASSWORD and PASSWORD128:
+    permission      allowed operation(s); comma separated list of
+                    'EDIT_DOCUMENT', 'EDIT_ANNOTATION', 'PRINT' and 'COPY'
+    password        password to open document/binder, or None
+    fullaccess      password to open document/binder with full-access
+                    privilege, or None
+    comment         notice in password dialogue, or None
+
+    **options for PKI:
+    permission      allowed operation(s); comma separated list of
+                    'EDIT_DOCUMENT', 'EDIT_ANNOTATION', 'PRINT' and 'COPY'
+    certificates    list of certificates in DER (RFC3280) formatted str
+    fullaccesscerts list of certificates in DER (RFC3280) formatted str
+
+    Returns the created pathname which may differ from output_path.
+    """
+    input_path = adjust_path(input_path)
+    root, ext = os.path.splitext(input_path)
+    output_path = adjust_path(output_path or root, ext=ext)
+    output_path = derivative_path(output_path)
+    protect_option = XDW_PROTECT_OPTION()
+    protect_option.nAuthMode = XDW_AUTH.normalize(auth)
+    protect_type = XDW_PROTECT.normalize(protect_type)
+    o = lambda s: options.get(s)
+    if protect_type in (XDW_PROTECT_PSWD, XDW_PROTECT_PSWD128, XDW_PROTECT_256):
+        opt = XDW_SECURITY_OPTION_PSWD()
+        opt.nPermission = flagvalue(XDW_PERM, o("permission"), store=True)
+        opt.szOpenPswd = o("password") or ""
+        opt.szFullAccessPswd = o("fullaccess") or ""
+        opt.lpszComment = o("comment") or ""
+    elif protect_type in (XDW_PROTECT_PKI, XDW_PROTECT_PKI256):
+        opt = XDW_SECURITY_OPTION_PKI()
+        opt.nPermission = flagvalue(XDW_PERM, o("permission"), store=True)
+        certificates = o("certificates")
+        if not certificates:
+            raise ValueError("a list of certificate(s) is required")
+        fullaccesscerts = o("fullacccesscerts")
+        opt.nCertsNum = len(certificates) + len(fullaccesscerts)
+        opt.nFullAccessCertsNum = len(fullaccesscerts)
+        certs = fullaccesscerts + certificates
+        ders = (XDW_DER_CERTIFICATE * opt.nCertsNum)()
+        for i in range(opt.nCertsNum):
+            ders[i].pCert = pointer(certs[i])
+            ders[i].nCertSize = len(certs[i])
+        opt.lpxdcCerts = byref(ders)
+    elif protect_type in (XDW_PROTECT_STAMP, XDW_PROTECT_CONTEXT_SERVICE):
+        raise NotImplementedError(
+                "only password- or PKI-based protection is available")
+    else:
+        raise ValueError("protect_type must be PASSWORD, PASSWORD128 or PKI")
+    try:
+        if XDWVER < 8:
+            XDW_ProtectDocument(cp(input_path), cp(output_path),
+                    protect_type, opt, protect_option)
+        else:
+            XDW_ProtectDocumentW(input_path, output_path,
+                    protect_type, opt, protect_option)
+    except ProtectModuleError as e:
+        msg = XDW_SECURITY_PKI_ERROR[opt.nErrorStatus]
+        if 0 <= opt.nFirstErrorCert:
+            msg += " in cert[%d]" % opt.nFirstErrorCert
+        raise ProtectModuleError(msg)
+    return output_path
+
+
+def unprotect(input_path, output_path=None, auth="NONE"):
+    """Release protection on document/binder.
+
+    auth            'NODIALOGUE' | 'CONDITIONAL'
+
+    Returns the created pathname which may differ from output_path.
+
+    NB. Only PKI-based or DocuWorks-builtin-stamp-based protected files are
+        processed.  Password-based protected files are beyond xdwlib.
+    """
+    input_path = adjust_path(input_path)
+    root, ext = os.path.splitext(input_path)
+    output_path = adjust_path(output_path or root, ext=ext)
+    output_path = derivative_path(output_path)
+    if protection_info(input_path)[0] not in ("PKI", "STAMP"):
+        raise ValueError("only PKI- or STAMP-protected file is acceptable")
+    auth = XDW_AUTH.normalize(auth)
+    if auth not in (XDW_AUTH_NODIALOGUE, XDW_AUTH_CONDITIONAL_DIALOGUE):
+        raise ValueError("auth must be NODIALOGUE or CONDITIONAL")
+    opt = XDW_RELEASE_PROTECTION_OPTION()
+    opt.nAuthMode = auth
+    if XDWVER < 8:
+        XDW_ReleaseProtectionOfDocument(cp(input_path), cp(output_path), opt)
+    else:
+        XDW_ReleaseProtectionOfDocumentW(input_path, output_path, opt)
+    return output_path
+
+
+def sign(input_path,
+        output_path=None,
+        page=0,
+        position=None,
+        type="STAMP",
+        certificate=None):
+    """Sign i.e. place a signature on document/binder page.
+
+    page            page number to paste signature on; starts with 0
+    position        (Point) position to paste signature on; default=(0, 0)
+    type            'STAMP' | 'PKI'
+    certificate     certificate in DER (RFC3280) formatted str; valid for PKI
+
+    Returns the created pathname which may differ from output_path.
+    """
+    input_path = adjust_path(input_path)
+    root, ext = os.path.splitext(input_path)
+    output_path = adjust_path(output_path or root, ext=ext)
+    output_path = derivative_path(output_path)
+    opt = XDW_SIGNATURE_OPTION_V5()
+    opt.nPage = page + 1
+    opt.nHorPos, opt.nVerPos = ((position or Point(0, 0)) * 100).int()
+    opt.nSignatureType = XDW_SIGNATURE.normalize(type)
+    type = XDW_SIGNATURE.normalize(type)
+    if type == XDW_SIGNATURE_STAMP:
+        modopt = None
+    else:  # opt.nSignatureType == XDW_SIGNATURE_PKI
+        modopt = XDW_SIGNATURE_MODULE_OPTION_PKI()
+        modopt.pSignerCert = ptr(cert)
+        modopt.nSignerCertSize = len(cert)
+    if XDWVER < 8:
+        XDW_SignDocument(cp(input_path), cp(output_path), opt, modopt)
+    else:
+        XDW_SignDocumentW(input_path, output_path, opt, modopt)
+    return output_path
+
+
+class AttachmentList(Subject):
+
+    """Collection of Attachments aka original data."""
+
+    def __init__(self, doc, size=None):
+        Subject.__init__(self)
+        self.doc = doc
+        if size:
+            self.size = size
+        else:
+            docinfo = XDW_GetDocumentInformation(doc.handle)
+            self.size = docinfo.nOriginalData
+
+    def __len__(self):
+        return self.size
+
+    def __iter__(self):
+        for pos in range(self.size):
+            yield self.attachment(pos)
+
+    def _pos(self, pos, append=False):
+        append = 1 if append else 0
+        if not (-self.size <= pos < self.size + append):
+            raise IndexError("Attachment #{0} not in [{1}, {2})".format(
+                    pos, -self.size, self.size + append))
+        if pos < 0:
+            pos += self.size
+        return pos
+
+    def attachment(self, pos):
+        """Get an attachment, aka original data."""
+        pos = self._pos(pos)
+        if pos not in self.observers:
+            self.observers[pos] = Attachment(self.doc, pos)
+        return self.observers[pos]
+
+    def __getitem__(self, pos):
+        return self.attachment(pos)
+
+    def append(self, path):
+        """Append an attachment, aka original data, at the end of XDW/XBD."""
+        return self.insert(self.size, path)
+
+    def insert(self, pos, path):
+        """Insert an attachment, aka original data.
+
+        pos     position to insert; starts with 0
+        path    pathname of a file to insert
+        """
+        pos = self._pos(pos, append=True)
+        XDW_InsertOriginalData(self.doc.handle, pos + 1, cp(path))
+        self.size += 1
+        att = self.attachment(pos)
+        self.attach(att, EV_ATT_INSERTED)
+
+    def delete(self, pos):
+        """Remove an attachment, aka original data."""
+        pos = self._pos(pos)
+        att = self.attachment(pos)
+        XDW_DeleteOriginalData(self.doc.handle, pos + 1)
+        self.detach(att, EV_ATT_REMOVED)
+        self.size -= 1
+
+    def __delitem__(self, pos):
+        self.delete(pos)
+
+
+class Attachment(Observer):
+
+    """Place holder for attachments aka original data."""
+
+    def __init__(self, doc, pos):
+        self.doc = doc
+        self.pos = pos
+        info, text_type = XDW_GetOriginalDataInformationW(
+                doc.handle, pos + 1, codepage=CP)
+        self.text_type = XDW_TEXT_TYPE[text_type]
+        self.size = info.nDataSize
+        self.datetime = fromunixtime(info.nDate)
+        self.name = info.szName
+
+    def name_compat(self, encoding, errors="ignore"):
+        info = XDW_GetOriginalDataInformation(
+                self.doc.handle, self.pos + 1)
+        return info.szName.decode(encoding, errors=errors)
+
+    def update(self, event):
+        """Update self as an observer."""
+        if not isinstance(event, Notification):
+            raise TypeError("not an instance of Notification class")
+        if event.type == EV_ATT_REMOVED:
+            if event.para[0] < self.pos:
+                self.pos -= 1
+        elif event.type == EV_ATT_INSERTED:
+            if event.para[0] < self.pos:
+                self.pos += 1
+        else:
+            raise ValueError(f"Illegal event type: {event.type}")
+
+    def save(self, path=None):
+        """Save attached file.
+
+        path    (str) save to {path};
+                      with no dir, save to {document/binder dir}/{path}
+                (None) save to {document/binder dir}/{stored filename}
+
+        Returns the saved pathname which may differ from path.
+        """
+        path = newpath(path or self.name, dir=self.doc.dirname())
+        if XDWVER < 8:
+            XDW_GetOriginalData(self.doc.handle, self.pos + 1, cp(path))
+        else:
+            XDW_GetOriginalDataW(self.doc.handle, self.pos + 1, path)
+        return path
+
+
+class XDWFile(object):
+
+    """Docuworks file XDW, XBD and XCT."""
+
+    @staticmethod
+    def all_attributes():  # for debugging
+        return [outer_attribute_name(k) for k in XDW_DOCUMENT_ATTRIBUTE_W]
+
+    def register(self):
+        VALID_DOCUMENT_HANDLES.append(self.handle)
+
+    def free(self):
+        VALID_DOCUMENT_HANDLES.remove(self.handle)
+
+    @staticmethod
+    def _free(handle):
+        VALID_DOCUMENT_HANDLES.remove(handle)
+
+    def __init__(self, path):
+        """Initiator.
+
+        Sets the following properties:
+            dir         (str) directory part of path
+            name        (str) filename without extension
+            type        (str) 'DOCUMENT' | 'BINDER' | 'CONTAINER'
+            protection  result of protection_info(path)
+
+        NB. value of `type' may be changed after actual open().
+        """
+        self.properties = None
+        self.signatures = None
+        self.dir, self.name = os.path.split(path)
+        self.name, ext = os.path.splitext(self.name)
+        self.handle = None
+        self.pages = 0
+        self.version = None
+        self.attachments = None
+        types = {"Document": XDW_DT_DOCUMENT, "Binder": XDW_DT_BINDER,
+                 "Container": XDW_DT_CONTAINER}
+        classname = self.__class__.__name__
+        self.type = XDW_DOCUMENT_TYPE[types[classname]]
+        self.editable = True
+        self.annotatable = True
+        self.printable = True
+        self.copyable = True
+        self._show_annotations = True
+        self.status = None
+        self.readonly = False
+        self.authenticate = False
+        self.protection = protection_info(path)
+
+    def open(self, readonly=False, authenticate=True, autosave=False):
+        """Opener."""
+        self._autosave = bool(autosave)
+        open_mode = XDW_OPEN_MODE_EX()
+        if readonly:
+            open_mode.nOption = XDW_OPEN_READONLY
+        else:
+            open_mode.nOption = XDW_OPEN_UPDATE
+        if authenticate:
+            open_mode.nAuthMode = XDW_AUTH_NODIALOGUE
+        else:
+            open_mode.nAuthMode = XDW_AUTH_NONE
+        if XDWVER < 8:
+            self.handle = XDW_OpenDocumentHandle(cp(self.pathname()), open_mode)
+        elif XDWVER < 9:
+            self.handle = XDW_OpenDocumentHandleW(self.pathname(), open_mode)
+        else:
+            self.handle = XDW_OpenDocumentHandleExW(self.pathname(), open_mode)
+        self.register()
+        # Set document properties.
+        docinfo = XDW_GetDocumentInformation(self.handle)
+        self.pages = docinfo.nPages
+        self.version = docinfo.nVersion - 3  # DocuWorks version
+        self.attachments = AttachmentList(self, size=docinfo.nOriginalData)
+        self.type = XDW_DOCUMENT_TYPE[docinfo.nDocType]
+        self.editable = bool(docinfo.nPermission & XDW_PERM_DOC_EDIT)
+        self.annotatable = bool(docinfo.nPermission & XDW_PERM_ANNO_EDIT)
+        self.printable = bool(docinfo.nPermission & XDW_PERM_PRINT)
+        self.copyable = bool(docinfo.nPermission & XDW_PERM_COPY)
+        self._show_annotations = bool(docinfo.nShowAnnotations)
+        # Followings are effective only for binders.
+        self.documents = docinfo.nDocuments
+        self.binder_color = XDW_BINDER_COLOR[docinfo.nBinderColor]
+        self.binder_size = XDW_BINDER_SIZE[docinfo.nBinderSize]
+        # Document attributes.
+        self._set_property_count()
+        # Attached signatures.
+        self._set_signature_count()
+        # Document verification status.
+        self.status = None
+        # Remember arguments for future use.
+        self.readonly = readonly
+        self.authenticate = authenticate
+        return self
+
+    def _set_property_count(self):
+        self.properties = XDW_GetDocumentAttributeNumber(self.handle)
+
+    def _set_signature_count(self):
+        self.signatures = XDW_GetDocumentSignatureNumber(self.handle)
+
+    def filename(self):
+        """Get filename with extension."""
+        exts = {"DOCUMENT": ".xdw", "BINDER": ".xbd", "CONTAINER": ".xct"}
+        return self.name + exts[self.type]
+
+    def pathname(self):
+        """Get full pathname with extension."""
+        return os.path.join(self.dir, self.filename())
+
+    def update_pages(self):
+        """Update number of pages; used after insert multiple pages in."""
+        docinfo = XDW_GetDocumentInformation(self.handle)
+        self.pages = docinfo.nPages
+
+    def save(self):
+        """Save document regardless of whether it is modified or not."""
+        XDW_SaveDocument(self.handle)
+
+    def close(self):
+        """Close document."""
+        if not self.handle:
+            return
+        if self._autosave:
+            self.save()
+        XDW_CloseDocumentHandle(self.handle)
+        self.free()
+        self.handle = None
+
+    @staticmethod
+    def _close(handle):
+        XDW_CloseDocumentHandle(handle)
+        XDWFile._free(handle)
+
+    @property
+    def show_annotations(self):
+        return self._show_annotations
+
+    @show_annotations.setter
+    def show_annotations(self, value):
+        value = bool(value)
+        XDW_ShowOrHideAnnotations(self.handle, value)
+        self._show_annotations = value
+        return
+
+    def __getattribute__(self, name):
+        attribute_name = inner_attribute_name(name)
+        if attribute_name not in XDW_DOCUMENT_ATTRIBUTE_W:
+            self_signatures = object.__getattribute__(self, "signatures")
+            if name == "status" and self_signatures:
+                self_signature = object.__getattribute__(self, "signature")
+                self_signature(0)  # Update document verification status.
+            return object.__getattribute__(self, name)
+        self_handle = object.__getattribute__(self, "handle")
+        t, value, _ = XDW_GetDocumentAttributeByNameW(
+                self_handle, attribute_name, codepage=CP)
+        return makevalue(t, value)
+
+    def __setattr__(self, name, value):
+        attribute_name = inner_attribute_name(name)
+        if attribute_name in XDW_DOCUMENT_ATTRIBUTE_W:
+            t, value = typevalue(value)
+            XDW_SetDocumentAttributeW(self.handle, attribute_name, t, value,
+                    XDW_TEXT_UNICODE_IFNECESSARY, codepage=CP)
+            return
+        object.__setattr__(self, name, value)
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.close()
+
+    def get_userattr(self, name, default=None):
+        """Get user defined attribute.
+
+        name        (str or bytes) attribute name in OEM encoding
+        default     value to return if no attribute named name exist
+        """
+        try:
+            if XDWVER < 8:
+                return XDW_GetUserAttribute(self.handle, cp(name))
+            else:
+                return XDW_GetUserAttributeW(self.handle, name)
+        except InvalidArgError:
+            return default
+
+    def set_userattr(self, name, value):
+        """Set user defined attribute.
+
+        name        (str or bytes) attribute name in OEM encoding
+        value       (str or bytes) attribute value in OEM encoding
+        """
+        if XDWVER < 8:
+            XDW_SetUserAttribute(self.handle, cp(name), value)
+        else:
+            XDW_SetUserAttributeW(self.handle, name, value)
+
+    def has_property(self, name):
+        """Test if user defined property exists.
+
+        name        (str) name of property
+
+        Returns True if such property exists, or False if not.
+        """
+        if not isinstance(name, str):
+            raise TypeError("property name must be str")
+        try:
+            t, value, _ = XDW_GetDocumentAttributeByNameW(
+                    self.handle, name, codepage=CP)
+        except InvalidArgError:
+            return False
+        return True
+
+    def get_property(self, name, default=None):
+        """Get user defined property.
+
+        name        (str) name of property, or user attribute
+                    (int) property order which starts with 0
+        default     value to return if no property named name exist
+
+        Returns a str, int, bool or datetime.date.
+
+        Note that previous set_property(bytes_value) gives str (i.e., unicode).
+        """
+        if isinstance(name, str):
+            try:
+                t, value, _ = XDW_GetDocumentAttributeByNameW(
+                        self.handle, name, codepage=CP)
+            except InvalidArgError:
+                return default
+        elif isinstance(name, int):
+            n = self.properties
+            if name < 0:
+                name += n
+            if not( 0 <= name < n):
+                raise IndexError("attribute order out of range [0, %d)" % n)
+            name, t, value, _ = XDW_GetDocumentAttributeByOrderW(
+                                            self.handle, name + 1)
+            return (name, makevalue(t, value))
+        else:
+            raise TypeError("name must be str or int")
+        return makevalue(t, value)
+
+    def set_property(self, name, value, update=True):
+        """Set user defined property.
+
+        name        (str) name of property, or user attribute
+        value       (str, bytes, int, bool or datetime.date) stored value
+                    (None) delete property if update==False
+        update      (bool) False=don't update value if exists already
+
+        Note that bytes value is actually stored in unicode and get_property()
+        will returen str (i.e., unicode str).
+        """
+        if not update and self.get_property(name) is not None:
+            return
+        if value is None:
+            self.del_property(name)
+            return
+        if isinstance(value, bytes):
+            value = uc(value)  # Force to store in unicode.
+        t, value = typevalue(value)
+        if t != XDW_ATYPE_STRING:
+            value = byref(value)
+        XDW_SetDocumentAttributeW(self.handle, name, t, value,
+                XDW_TEXT_UNICODE_IFNECESSARY, codepage=CP)
+        self._set_property_count()
+
+    def del_property(self, name):
+        """Delete user defined property.
+
+        name        (str) name of property, or user attribute
+        """
+        XDW_SetDocumentAttributeW(self.handle, name, XDW_ATYPE_INT, NULL,
+                XDW_TEXT_UNICODE_IFNECESSARY, codepage=CP)
+        self._set_property_count()
+
+    hasprop = has_property
+    getprop = get_property
+    setprop = set_property
+    delprop = del_property
+
+    def pageform(self, form):
+        return PageForm(self, form)
+
+    def pageform_text(self):
+        """Get all text in page form."""
+        return ASEP.join(self.pageform(form).text
+                for form in ("header", "footer"))
+
+    def update_pageform(self, sync=False):
+        """Update page form.
+
+        sync        (bool) also update pageforms for documents in binder
+        """
+        sync = XDW_PAGEFORM_REMOVE if sync else XDW_PAGEFORM_STAY
+        XDW_UpdatePageForm(self.handle, sync)
+
+    def delete_pageform(self, sync=False):
+        """Delete page form.
+
+        sync        (bool) also delete pageforms for documents in binder
+        """
+        sync = XDW_PAGEFORM_REMOVE if sync else XDW_PAGEFORM_STAY
+        XDW_RemovePageForm(self.handle, sync)
+
+    updform = update_pageform
+    delform = delete_pageform
+
+    def signature(self, pos):
+        """Get signature information.
+
+        Returns StampSignature or PKISignature object.
+        """
+        siginfo, modinfo = XDW_GetSignatureInformation(self.handle, pos + 1)
+        if siginfo.nSignatureType == XDW_SIGNATURE_STAMP:
+            sts = XDW_SIGNATURE_STAMP_STAMP[modinfo.nStampVerificationStatus]
+            docsts = XDW_SIGNATURE_STAMP_DOC[modinfo.nDocVerificationStatus]
+            sig = StampSignature(
+                    self,
+                    pos,
+                    siginfo.nPage - 1,
+                    Point(siginfo.nHorPos, siginfo.nVerPos) / 100.0,
+                    Point(siginfo.nWidth, siginfo.nHeight) / 100.0,
+                    fromunixtime(siginfo.nSignedTime),
+                    stamp_name=modinfo.lpszStampName,
+                    owner_name=modinfo.lpszOwnerName,
+                    valid_until=fromunixtime(modinfo.nValidDate),
+                    memo=modinfo.lpszRemarks,
+                    status=sts,
+                    )
+            self.status = docsts
+        else:  # siginfo.nSignatureType == XDW_SIGNATURE_PKI
+
+            def parsedt(s):
+                return datetime.datetime.strptime(s.decode("ascii"),
+                                                  "%Y/%m/%d %H:%M:%S")
+
+            ver = XDW_SIGNATURE_PKI_TYPE[modinfo.nCertVerificationType]
+            sts = XDW_SIGNATURE_PKI_CERT[modinfo.nCertVerificationStatus]
+            docsts = XDW_SIGNATURE_PKI_DOC[modinfo.nDocVerificationStatus]
+            sig = PKISignature(
+                    self,
+                    pos,
+                    siginfo.nPage - 1,
+                    Point(siginfo.nHorPos, siginfo.nVerPos) / 100.0,
+                    Point(siginfo.nWidth, siginfo.nHeight) / 100.0,
+                    fromunixtime(siginfo.nSignedTime),
+                    module=modinfo.lpszModule,
+                    subjectdn=modinfo.lpszSubjectDN,
+                    subject=modinfo.lpszSubject,
+                    issuerdn=modinfo.lpszIssuerDN,
+                    issuer=modinfo.lpszIssuer,
+                    not_before=parsedt(modinfo.lpszNotBefore),
+                    not_after=parsedt(modinfo.lpszNotAfter),
+                    serial=modinfo.lpszSerial,
+                    certificate=modinfo.signer_cert,
+                    memo=modinfo.lpszRemarks,
+                    signing_time=parsedt(modinfo.lpszSigningTime),
+                    verification_type=ver,
+                    status=sts,
+                    )
+            self.status = docsts
+        return sig
+
+    def _process(self, meth, *args, **kw):
+        selfpath = self.pathname()
+        oldhandle = self.handle
+        if oldhandle:
+            self.save()
+            self.close()
+        new_selfpath = meth(selfpath, *args, **kw)
+        if kw.get("output_path"):
+            if oldhandle:
+                self.open(readonly=self.readonly,
+                        authenticate=self.authenticate,
+                        autosave=self._autosave)
+            return new_selfpath
+        # Swap the old for the new, and remove the old.
+        os.remove(selfpath)
+        os.rename(new_selfpath, selfpath)
+        if oldhandle:
+            self.open(readonly=self.readonly,
+                    authenticate=self.authenticate,
+                    autosave=self._autosave)
+            # Renew related attributes.
+            self.signatures = XDW_GetDocumentSignatureNumber(self.handle)
+            self.status = None
+
+    def sign(self,
+            output_path=None,
+            page=0,
+            position=None,
+            type="STAMP",
+            certificate=None):
+        """Sign i.e. attach signature.
+
+        See xdwfile.sign() for arguments.
+
+        Returns the created pathname which may differ from output_path,
+        if called with output_path specified.
+
+        NB. self.save() is performed internally.
+        """
+        return self._process(sign, output_path=output_path, page=page,
+                position=position, type=type, certificate=certificate)
+
+    def protect(self,
+            output_path=None,
+            protect_type="PASSWORD",
+            auth="NONE",
+            **options):
+        """Protect document/binder.
+
+        See xdwfile.protect() for arguments.
+
+        Returns the created pathname which may differ from output_path,
+        if called with output_path specified.
+
+        NB. Only password- or PKI-based protection is available.
+        NB. self.save() is performed internally.
+        """
+        return self._process(protect, output_path=output_path,
+                protect_type=protect_type, auth=auth, **options)
+
+    def unprotect(self, output_path=None, auth="NONE"):
+        """Release protection on document/binder.
+
+        See xdwfile.unprotect() for arguments.
+
+        Returns the created pathname which may differ from output_path,
+        if called with output_path specified.
+
+        NB. Only PKI- or STAMP-protected file is acceptable.
+        NB. self.save() is performed internally.
+        """
+        return self._process(unprotect, output_path=output_path, auth=auth)
+
+    def optimize(self, output_path=None):
+        """Optimize document/binder file.
+
+        See xdwfile.optimize() for arguments.
+
+        Returns the created pathname which may differ from output_path,
+        if called with output_path specified.
+
+        NB. self.save() is performed internally.
+        """
+        return self._process(optimize, output_path=output_path)
+
+
+class BaseSignature(object):
+
+    """Base class for StampSignature and PKISignature."""
+
+    def __init__(self, doc, pos, pagepos, position, size, dt):
+        """Initiator.
+
+        doc             Document/Binder
+        pos             position in signature list of doc; starts with 0
+        pagepos         page number to paste signature on; starts with 0
+        position        (Point) position in mm to paste signature on
+        size            (Point) size in mm to show signature
+        dt              (datetime.datetime) signed datetime
+        """
+        self.doc = doc
+        self.pos = pos
+        self.pagepos = pagepos
+        self.position = position
+        self.size = size
+        self.dt = dt
+
+    def __repr__(self):
+        return  "{cls}({doc}[{pos}])".format(
+                cls=self.__class__.__name__,
+                doc=self.doc.name,
+                pos=self.pos,
+                )
+
+    def __str__(self):
+        return  "{cls}({doc}[{pos}]; page {pgpos}, position {loc}mm)".format(
+                cls=self.__class__.__name__,
+                doc=self.doc.name,
+                pos=self.pos,
+                pgpos=self.pagepos,
+                loc="({0:.2f}, {1:.2f})".format(*self.position),
+                )
+
+    def update(self):
+        """Update signature status.
+
+        Returns (signature_type, error_status).
+
+        N.B. self.doc.status may be altered.
+        """
+        status = XDW_UpdateSignatureStatus(self.doc.handle, self.pos + 1)
+        return (XDW_SIGNATURE[status.nSignatureType],
+                {
+                    XDW_SIGNATURE_STAMP: XDW_SIGNATURE_STAMP_ERROR,
+                    XDW_SIGNATURE_PKI: XDW_SIGNATURE_PKI_ERROR,
+                }[status.nSignatureType][status.nErrorStatus])
+
+
+class StampSignature(BaseSignature):
+
+    """DocuWorks' built-in stamp signature."""
+
+    def __init__(self, doc, pos, pagepos, position, size, dt,
+            stamp_name="",
+            owner_name="",
+            valid_until=None,
+            memo="",
+            status=None,
+            ):
+        """Initiator.
+
+        doc             Document/Binder
+        pos             position in signature list of doc; starts with 0
+        pagepos         page number to paste signature on; starts with 0
+        position        (Point) position to paste signature on
+        size            (Point) size to show signature
+        dt              (datetime.datetime) signed datetime
+        stamp_name      stamp's name
+        owner_name      owner's name
+        valid_until     (datetime.datetime) ending time of validity
+        memo            (str)
+        status          "NONE" | "TRUSTED" | "NOTRUST"
+        """
+        BaseSignature.__init__(self, doc, pos, pagepos, position, size, dt)
+        self.stamp_name = stamp_name
+        self.owner_name = owner_name
+        self.valid_until = valid_until
+        self.memo = memo
+        self.status = status
+
+
+class PKISignature(BaseSignature):
+
+    """PKI-based signature."""
+
+    def __init__(self, doc, pos, pagepos, position, size, dt,
+            module="",
+            subjectdn="",
+            subject="",
+            issuerdn="",
+            issuer="",
+            not_before=None,
+            not_after=None,
+            serial=None,
+            certificate=None,
+            memo="",
+            signing_time=None,
+            verification_type=None,
+            status=None,
+            ):
+        """Initiator.
+
+        doc             Document/Binder
+        pos             position in signature list of doc; starts with 0
+        pagepos         page number to paste signature on; starts with 0
+        position        (Point) position to paste signature on
+        size            (Point) size to show signature
+        dt              (datetime.datetime) signed datetime
+        module          security module name
+        subjectdn       content of SUBJECT DN (distinguished name);
+                        max. 511 bytes
+        subject         content of SUBJECT; CN, OU, O or E
+        issuerdn        content of ISSUER DN (distinguished name);
+                        max. 511 bytes
+        issuer          content of ISSUER; CN, OU, O or E
+        not_before      (datetime.datetime)
+        not_after       (datetime.datetime)
+        serial          (str)
+        certificate     (str) content of singer certificate in DER (RFC3280)
+                        format
+        memo            (str)
+        signing_time    (datetime.datetime)
+        verification_type   'LOW' | 'MID_LOCAL' | 'MID_NETWORK' |
+                            'HIGH_LOCAL' | 'HIGH_NETWORK'
+        status          'UNKNOWN' | 'OK' | 'NO_ROOT_CERTIFICATE' |
+                        'NO_REVOCATION_CHECK' | OUT_OF_VALIDITY' |
+                        'OUT_OF_VALIDITY_AT_SIGNED_TIME |
+                        'REVOKE_CERTIFICATE' |
+                        'REVOKE_INTERMEDIATE_CERTIFICATE' |
+                        'INVLIAD_SIGNATURE' | 'INVALID_USAGE' |
+                        'UNDEFINED_ERROR'
+        """
+        BaseSignature.__init__(self, doc, pos, pagepos, position, size, dt)
+        self.module = module
+        self.subjectdn = subjectdn[:511]  # max. 511 bytes
+        self.subject = subject  # CN, OU, O or E
+        self.issuerdn = issuerdn[:511]  # max. 511 bytes
+        self.issuer = issuer  # CN, OU, O or E
+        self.not_before = not_before
+        self.not_after = not_after
+        self.serial = serial
+        self.certificate = certificate
+        self.memo = memo
+        self.signing_time = signing_time
+        self.verification_type = verification_type
+        self.status = status
+
+
+class PageForm(object):
+
+    """Header/footer of document."""
+
+    @staticmethod
+    def all_types():
+        """Return all pageform types for convenience."""
+        return tuple(sorted(XDW_PAGEFORM.values()))
+
+    @staticmethod
+    def all_attributes():
+        """Return all pageform attributes for convenience."""
+        return tuple(sorted(
+                "alignment back_color beginning_page digit doc ending_page "
+                "font_char_set font_name font_pitch_and_family font_size "
+                "font_style fore_color form image_file left_right_margin "
+                "page_range starting_number text top_bottom_margin "
+                "ver_position zoom".split()))
+
+    @staticmethod
+    def all_colors():
+        """Returns all colors available."""
+        return tuple(sorted(XDW_COLOR.values()))
+
+    def __init__(self, doc, form):
+        self.__dict__["doc"] = doc
+        self.__dict__["form"] = XDW_PAGEFORM.normalize(form)
+
+    def __repr__(self):
+        return "{cls}({doc}.{attr})".format(
+                cls=self.__class__.__name__,
+                doc=self.doc,
+                attr=outer_attribute_name(XDW_PAGEFORM[self.form]))
+
+    @property
+    def form(self):
+        return self.__dict__["form"]
+
+    @form.setter
+    def form(self, value):
+        object.__setattr__(self, "form", XDW_PAGEFORM.normalize(value))
+
+    def __setattr__(self, name, value):
+        attrname = inner_attribute_name(name)
+        if attrname not in XDW_ANNOTATION_ATTRIBUTE:
+            object.__setattr__(self, name, value)
+            return
+        special = isinstance(XDW_ANNOTATION_ATTRIBUTE[attrname][1], XDWConst)
+        if special or isinstance(value, (int, float)):
+            value = int(scale(attrname, value, store=True))
+            if attrname.endswith("Page"):
+                value += 1  # 1-based
+            value = byref(c_int(value))
+            attribute_type = XDW_ATYPE_INT  # TODO: Scaling may be required.
+        elif isinstance(value, (str, bytes)):
+            attribute_type = XDW_ATYPE_STRING
+            """TODO: unicode handling.
+            Currently Author has no idea to take unicode with ord < 256.
+            Python's unicode may have inner representation with 0x00,
+            e.g.  0x41 0x00 0x42 0x00 0x43 0x00 for "ABC".  This results in
+            unexpected string termination e.g. "ABC" -> "A".  So, if the next
+            if-block is not placed, you will get much more but inexact
+            elements in result for abbreviated search string.
+            """
+            value = cp(value)  # TODO: unicode handling
+            if 255 < len(value):
+                raise ValueError("text length must be <= 255")
+        # TODO: XDW_ATYPE_OTHER should also be valid.
+        else:
+            raise TypeError("illegal value " + repr(value))
+        XDW_SetPageFormAttribute(self.doc.handle, self.form,
+                cp(attrname), attribute_type, value)
+
+    def __getattribute__(self, name):
+        attrname = inner_attribute_name(name)
+        if attrname not in XDW_ANNOTATION_ATTRIBUTE:
+            return object.__getattribute__(self, name)
+        self_doc = object.__getattribute__(self, "doc")
+        self_form = object.__getattribute__(self, "form")
+        value = XDW_GetPageFormAttribute(self_doc.handle, self_form, cp(attrname))
+        attribute_type = XDW_ANNOTATION_ATTRIBUTE[attrname][0]
+        if attribute_type == 1:  # string
+            return uc(value)
+        value = unpack(value)
+        if attrname.endswith("Page"):
+            value -= 1  # 0-based
+        return scale(attrname, value, store=False)
+
+    def update(self, sync=False):
+        """Update page form.
+
+        sync    (bool) also update pageforms for documents in binder
+        """
+        sync = XDW_PAGEFORM_REMOVE if sync else XDW_PAGEFORM_STAY
+        XDW_UpdatePageForm(self.doc.handle, sync)
+
+    def delete(self, sync=False):
+        """Delete page form.
+
+        sync    (bool) also delete pageforms for documents in binder
+        """
+        sync = XDW_PAGEFORM_REMOVE if sync else XDW_PAGEFORM_STAY
+        XDW_RemovePageForm(self.doc.handle, sync)
```

## Comparing `xdwlib-3.9.6/xdwlib/xdwtemp.py` & `xdwlib-3.9.7/xdwlib/xdwtemp.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/__init__.py` & `xdwlib-3.9.7/xdwlib/__init__.py`

 * *Files identical despite different names*

## Comparing `xdwlib-3.9.6/xdwlib/__setup__.py` & `xdwlib-3.9.7/xdwlib/__setup__.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,13 +12,13 @@
 WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
 FOR A PARTICULAR PURPOSE.
 """
 
 __author__ = "HAYASHI Hideki"
 __copyright__ = "Copyright (C) 2010 HAYASHI Hideki <hideki@hayasix.com>"
 __license__ = "ZPL 2.1"
-__version__ = "3.9.6"
+__version__ = "3.9.7"
 __email__ = "hideki@hayasix.com"
 __status__ = "Beta"
 
 __all__ = ("__author__", "__copyright__", "__license__", "__version__",
            "__email__", "__status__")
```

## Comparing `xdwlib-3.9.6/xdwlib.egg-info/PKG-INFO` & `xdwlib-3.9.7/xdwlib.egg-info/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 Metadata-Version: 1.2
 Name: xdwlib
-Version: 3.9.6
+Version: 3.9.7
 Summary: A DocuWorks library.
 Home-page: https://github.com/hayasix/xdwlib
 Author: HAYASHI Hideki
 Author-email: hideki@hayasix.com
 License: UNKNOWN
 Description: =============
         Xdwlib README
         =============
         
-        2022-01-30 HAYASHI Hideki <hideki@hayasix.com>
+        2022-11-08 HAYASHI Hideki <hideki@hayasix.com>
         
         
         Welcome to the xdwlib source release
         ====================================
         
         Xdwlib is a DocuWorks library for Python.
         
@@ -90,14 +90,23 @@
         with cx_Freeze package, a popular successor of py2exe.  To build your
         own ``xdw2text.exe``, try::
         
             pip3 install cx_Freeze
             python3 cx_setup.py build
         
         
+        Documentation
+        =============
+        
+        Detailed documents are available in Japanese at
+        `Read the Docs <https://xdwlib.readthedocs.io/ja/latest>`_.
+        
+        Python's help() also gives brief descriptions in English.
+        
+        
         Typical Use
         ===========
         
         The following code will appy OCR and paste a date stamp on every page
         as an annotation::
         
             import time
```

## Comparing `xdwlib-3.9.6/xdwlib.egg-info/SOURCES.txt` & `xdwlib-3.9.7/xdwlib.egg-info/SOURCES.txt`

 * *Files 5% similar despite different names*

```diff
@@ -29,15 +29,14 @@
 docs/mergetest.jpg
 docs/modules.rst
 docs/overview.rst
 docs/page.rst
 docs/samples.rst
 docs/setup.rst
 docs/struct.rst
-docs/whatsthis.rst
 docs/xdw2text.rst
 docs/xdwfile.rst
 docs/xdwlib.rst
 docs/xdwtemp.rst
 scripts/xdw2text.py
 xdwlib/__init__.py
 xdwlib/__setup__.py
```

