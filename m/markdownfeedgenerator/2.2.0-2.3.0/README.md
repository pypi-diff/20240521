# Comparing `tmp/markdownfeedgenerator-2.2.0-py3-none-any.whl.zip` & `tmp/markdownfeedgenerator-2.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 17598 bytes, number of entries: 23
--rw-r--r--  2.0 unx      607 b- defN 24-May-17 19:00 markdownfeedgenerator/Gatherer.py
--rw-r--r--  2.0 unx     4962 b- defN 24-May-17 19:00 markdownfeedgenerator/MarkdownFile.py
--rw-r--r--  2.0 unx     1158 b- defN 24-May-17 19:00 markdownfeedgenerator/__init__.py
--rw-r--r--  2.0 unx      341 b- defN 24-May-17 19:00 markdownfeedgenerator/Exceptions/__init__.py
--rw-r--r--  2.0 unx     8259 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Default/DefaultFeedGenerator.py
--rw-r--r--  2.0 unx     1158 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Default/DefaultFeedGeneratorSettings.py
--rw-r--r--  2.0 unx      820 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Default/Models/Feed.py
--rw-r--r--  2.0 unx      156 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Default/Models/FeedItem.py
--rw-r--r--  2.0 unx     1151 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Default/Models/__init__.py
--rw-r--r--  2.0 unx     2430 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Html/HtmlFeedGenerator.py
--rw-r--r--  2.0 unx     2753 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Html/template.html
--rw-r--r--  2.0 unx     3246 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Json/JsonFeedGenerator.py
--rw-r--r--  2.0 unx      703 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Json/JsonFeedGeneratorSettings.py
--rw-r--r--  2.0 unx      676 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Json/Models/Author.py
--rw-r--r--  2.0 unx      547 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Json/Models/Hub.py
--rw-r--r--  2.0 unx     1999 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Json/Models/JsonFeed.py
--rw-r--r--  2.0 unx     1555 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Json/Models/JsonFeedItem.py
--rw-r--r--  2.0 unx      483 b- defN 24-May-17 19:00 markdownfeedgenerator/Generators/Json/Models/__init__.py
--rw-r--r--  2.0 unx     1072 b- defN 24-May-17 19:01 markdownfeedgenerator-2.2.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     3052 b- defN 24-May-17 19:01 markdownfeedgenerator-2.2.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-May-17 19:01 markdownfeedgenerator-2.2.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       22 b- defN 24-May-17 19:01 markdownfeedgenerator-2.2.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2440 b- defN 24-May-17 19:01 markdownfeedgenerator-2.2.0.dist-info/RECORD
-23 files, 39682 bytes uncompressed, 13438 bytes compressed:  66.1%
+Zip file size: 18437 bytes, number of entries: 23
+-rw-r--r--  2.0 unx      645 b- defN 24-May-20 18:18 markdownfeedgenerator/Gatherer.py
+-rw-r--r--  2.0 unx     5507 b- defN 24-May-20 18:18 markdownfeedgenerator/MarkdownFile.py
+-rw-r--r--  2.0 unx     1192 b- defN 24-May-20 18:18 markdownfeedgenerator/__init__.py
+-rw-r--r--  2.0 unx      341 b- defN 24-May-20 18:18 markdownfeedgenerator/Exceptions/__init__.py
+-rw-r--r--  2.0 unx     8952 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Default/DefaultFeedGenerator.py
+-rw-r--r--  2.0 unx     1155 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Default/DefaultFeedGeneratorSettings.py
+-rw-r--r--  2.0 unx     1285 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Default/Models/Feed.py
+-rw-r--r--  2.0 unx      170 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Default/Models/FeedItem.py
+-rw-r--r--  2.0 unx     1824 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Default/Models/__init__.py
+-rw-r--r--  2.0 unx     2335 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Html/HtmlFeedGenerator.py
+-rw-r--r--  2.0 unx     2753 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Html/template.html
+-rw-r--r--  2.0 unx     3331 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Json/JsonFeedGenerator.py
+-rw-r--r--  2.0 unx      642 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Json/JsonFeedGeneratorSettings.py
+-rw-r--r--  2.0 unx      728 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Json/Models/Author.py
+-rw-r--r--  2.0 unx      587 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Json/Models/Hub.py
+-rw-r--r--  2.0 unx     1761 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Json/Models/JsonFeed.py
+-rw-r--r--  2.0 unx     1587 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Json/Models/JsonFeedItem.py
+-rw-r--r--  2.0 unx     1681 b- defN 24-May-20 18:18 markdownfeedgenerator/Generators/Json/Models/__init__.py
+-rw-r--r--  2.0 unx     1072 b- defN 24-May-20 18:18 markdownfeedgenerator-2.3.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3052 b- defN 24-May-20 18:18 markdownfeedgenerator-2.3.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-20 18:18 markdownfeedgenerator-2.3.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       22 b- defN 24-May-20 18:18 markdownfeedgenerator-2.3.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2442 b- defN 24-May-20 18:18 markdownfeedgenerator-2.3.0.dist-info/RECORD
+23 files, 43156 bytes uncompressed, 14277 bytes compressed:  66.9%
```

## zipnote {}

```diff
@@ -48,23 +48,23 @@
 
 Filename: markdownfeedgenerator/Generators/Json/Models/JsonFeedItem.py
 Comment: 
 
 Filename: markdownfeedgenerator/Generators/Json/Models/__init__.py
 Comment: 
 
-Filename: markdownfeedgenerator-2.2.0.dist-info/LICENSE
+Filename: markdownfeedgenerator-2.3.0.dist-info/LICENSE
 Comment: 
 
-Filename: markdownfeedgenerator-2.2.0.dist-info/METADATA
+Filename: markdownfeedgenerator-2.3.0.dist-info/METADATA
 Comment: 
 
-Filename: markdownfeedgenerator-2.2.0.dist-info/WHEEL
+Filename: markdownfeedgenerator-2.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: markdownfeedgenerator-2.2.0.dist-info/top_level.txt
+Filename: markdownfeedgenerator-2.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: markdownfeedgenerator-2.2.0.dist-info/RECORD
+Filename: markdownfeedgenerator-2.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## markdownfeedgenerator/Gatherer.py

```diff
@@ -1,29 +1,36 @@
 import asyncio
 
 
 class Gatherer:
     """
     Wrapper class to group feeds and run them async style.
     """
-    def __init__(self, feeds: list = None):
+
+    def __init__(
+        self,
+        feeds: list = None
+    ):
         """
         Provide a list of feeds to generate.
         """
         if feeds is None:
             feeds = []
 
         self.feeds = feeds
 
-    async def __generate(self):
+    async def __generate(
+        self
+    ):
         """
         Generate a feed.
         """
-        await asyncio.gather(
-            *[generator.run() for generator in self.feeds])
+        await asyncio.gather(*[generator.run() for generator in self.feeds])
 
-    def generate(self):
+    def generate(
+        self
+    ):
         """
         Generate all the feeds.
         :return:
         """
         asyncio.run(self.__generate())
```

## markdownfeedgenerator/MarkdownFile.py

```diff
@@ -1,88 +1,105 @@
 import hashlib
+import logging
 import os.path
 import re
 
 import html2text
 import markdown
 import yaml
-
 from dateutil import parser
 
 from markdownfeedgenerator import read_from_file
 from markdownfeedgenerator.Exceptions import DateParseError, TitleNotFoundError, InvalidMarkdownFrontMatterError
 
 
 class MarkdownFile:
     """
-    This class represents a single Markdown file. The markdown file should contain front-matter and contents.
+    This class represents a single Markdown file. The markdown file should contain front-matter and contents. Please
+    see https://jekyllrb.com/docs/collections/#add-content for more information.
     """
 
-    def __init__(self, file_path: str = '', front_matter: dict = None, body: str = ''):
+    def __init__(
+        self,
+        file_path: str = '',
+        front_matter: dict = None,
+        body: str = ''
+    ):
         """
         Construct the markdown file.
         :param file_path:
         :param front_matter:
         :param body:
         """
         if not front_matter:
             front_matter = {}
 
         self.file_path = file_path
         self.front_matter = front_matter
         self.body = body.strip('\n')
 
     @property
-    def file_name(self) -> str:
+    def file_name(
+        self
+    ) -> str:
         """
         Return the file name of the markdown file.
         :return:
         """
         return os.path.basename(self.file_path)
 
     @property
-    def location(self) -> str:
+    def location(
+        self
+    ) -> str:
         """
         Return the location of the current file
         """
         return os.path.dirname(self.file_path)
 
     @property
-    def filtered_front_matter(self) -> dict:
+    def filtered_front_matter(
+        self
+    ) -> dict:
         """
         Returns the front-matter properties with the dynamic fields such as id, title and date removed.
         """
         skip = ['id', 'title', 'date', 'summary']
         return {key: value for key, value in self.front_matter.items() if key not in skip}
 
     @property
-    def id(self):
+    def id(
+        self
+    ):
         """
         Generate a unique id using the file path.
         :return:
         """
         if 'id' in self.front_matter:
             return self.front_matter['id']
 
-        return hashlib.sha1(
-            self.file_path.encode('utf-8')).hexdigest()
+        return hashlib.sha1(self.file_path.encode('utf-8')).hexdigest()
 
     @property
-    def title(self) -> str:
+    def title(
+        self
+    ) -> str:
         """
         Return the title of the markdown file.
         :return:
         """
         if 'title' in self.front_matter:
             return self.front_matter['title']
 
         raise TitleNotFoundError('No title value was found in front-matter.')
 
     @property
-    def date(self):
+    def date(
+        self
+    ):
         """
         Attempts to find the date of a file. First priority is a date value in the front-matter. If nothing is found,
         will attempt to extract from the file name. Can possibly return None if no value is found. If a date is found,
         will parse it raising a DateParseError error if/on failure.
         :return:
         """
         date = None
@@ -100,64 +117,85 @@
                 return parser.parse(date)
             except ValueError or OverflowError:
                 raise DateParseError('Unable to parse the date from the front-matter, incorrect format.')
 
         return date
 
     @property
-    def html(self) -> str:
+    def html(
+        self
+    ) -> str:
         """
         Convert the markdown contents to html.
         :return:
         """
         return MarkdownFile.markdown_to_html(self.body)
 
     @property
-    def summary(self, max_length: int = 100) -> str:
+    def summary(
+        self,
+        max_length: int = 100
+    ) -> str:
         """
         Generate a summary of the file. If summary is in front-matter, will use that. If not, it will attempt to
         generate one from the content of the file.
         :return:
         """
-        summary = self.front_matter['summary'] \
-            if 'summary' in self.front_matter \
-            else html2text.html2text(self.html)
+        summary = self.front_matter['summary'] if 'summary' in self.front_matter else html2text.html2text(self.html)
 
         summary = summary.replace('\n', ' ')
 
         if len(summary) > max_length:
             return summary[0:max_length].strip() + '..'
 
         return summary.strip('\n').strip()
 
     @staticmethod
-    def load(markdown_file_path: str, encoding: str = 'utf-8'):
+    def load(
+        markdown_file_path: str,
+        encoding: str = 'utf-8'
+    ):
         """
         Load a markdown file from a file on disk.
         :param markdown_file_path:
         :param encoding:
         :return:
         """
+        logging.info(f'Loading Markdown file at path "{markdown_file_path}".')
+
         if not os.path.exists(markdown_file_path):
             raise FileNotFoundError(f'The markdown file "{markdown_file_path}", does not exist.')
 
         file_segments = read_from_file(markdown_file_path, encoding).split('---', 2)
 
         if len(file_segments) != 3:
-            raise InvalidMarkdownFrontMatterError(
-                f'Markdown file "{markdown_file_path}" is in an incorrect format.')
+            raise InvalidMarkdownFrontMatterError(f'Markdown file "{markdown_file_path}" is in an incorrect format.')
 
         front_matter = yaml.safe_load(file_segments[1])
 
         if type(front_matter) is not dict:
-            raise InvalidMarkdownFrontMatterError(
-                f'Markdown file "{markdown_file_path}" has invalid front-matter.')
+            raise InvalidMarkdownFrontMatterError(f'Markdown file "{markdown_file_path}" has invalid front-matter.')
 
-        return MarkdownFile(
-            markdown_file_path, front_matter, file_segments[2])
+        return MarkdownFile(markdown_file_path, front_matter, file_segments[2])
 
     @staticmethod
-    def markdown_to_html(markdown_content: str) -> str:
+    def markdown_to_html(
+        markdown_content: str
+    ) -> str:
         """
         Convert Markdown to HTML.
         """
         return markdown.markdown(markdown_content, extensions=['fenced_code', 'tables'])
+
+    def __str__(
+        self
+    ):
+        """
+        Override for easier debugging.
+        """
+        if self.file_path:
+            return self.file_path
+
+        if self.title:
+            return self.title
+
+        return 'Untitled Markdown File'
```

## markdownfeedgenerator/__init__.py

```diff
@@ -1,14 +1,18 @@
 import os
 
 import requests
 from requests import Response
 
 
-def write_to_file(file_path: str, content, encoding: str = 'utf-8') -> None:
+def write_to_file(
+    file_path: str,
+    content,
+    encoding: str = 'utf-8'
+) -> None:
     """
     Write some contents to a specific file.
     :param encoding:
     :param file_path:
     :param content:
     :return:
     """
@@ -17,29 +21,35 @@
     if not os.path.exists(dir_path):
         os.makedirs(dir_path)
 
     with open(file_path, 'w', encoding=encoding) as file:
         file.write(content)
 
 
-def read_from_file(file_path: str, encoding: str = 'utf-8') -> any:
+def read_from_file(
+    file_path: str,
+    encoding: str = 'utf-8'
+) -> any:
     """
     Read from a file.
     """
     if not os.path.exists(file_path):
         raise FileNotFoundError(f'The file at path "{file_path}" was not found.')
 
     if not os.path.isfile(file_path):
         raise ValueError(f'The file at path "{file_path}" is not actually a fail.')
 
     with open(file_path, encoding=encoding, errors=None) as f:
         return f.read()
 
 
-def read_from_url(url: str, bearer_token: str = None) -> Response:
+def read_from_url(
+    url: str,
+    bearer_token: str = None
+) -> Response:
     """
     Read from url.
     """
     headers = {}
 
     if bearer_token:
         headers['Authorization'] = f'Bearer {bearer_token}'
```

## markdownfeedgenerator/Generators/Default/DefaultFeedGenerator.py

```diff
@@ -1,228 +1,288 @@
 import asyncio
 import json
-import os
 import logging
+import os
+from concurrent.futures.thread import ThreadPoolExecutor
+from math import ceil
 from pathlib import Path
 from typing import Callable
 
-from math import ceil
-
-from markdownfeedgenerator.MarkdownFile import MarkdownFile
 from markdownfeedgenerator.Generators.Default.DefaultFeedGeneratorSettings import DefaultFeedGeneratorSettings
-from markdownfeedgenerator.Generators.Default.Models import ItemStore
 from markdownfeedgenerator.Generators.Default.Models.Feed import Feed
 from markdownfeedgenerator.Generators.Default.Models.FeedItem import FeedItem
+from markdownfeedgenerator.MarkdownFile import MarkdownFile
 
 
 class DefaultFeedGenerator:
-    def __init__(self, feed_details: Feed = None, generator_settings: DefaultFeedGeneratorSettings = None):
-        if not feed_details:
-            feed_details = ItemStore()
+    def __init__(
+        self,
+        feed: Feed = None,
+        generator_settings: DefaultFeedGeneratorSettings = None
+    ):
+        if not feed:
+            feed_details = Feed()
             feed_details.set('title', 'Untitled Feed')
 
         if not generator_settings:
             generator_settings = DefaultFeedGeneratorSettings()
 
         logging.info(f'Using generator with settings: "{str(generator_settings)}"')
 
-        self.feed_details = feed_details
+        self.feed = feed
         self.generator_settings = generator_settings
 
         self._check_settings()
 
-    async def run(self) -> None:
+    async def run(
+        self
+    ) -> None:
         # Discover markdown file paths
         markdown_file_paths = DefaultFeedGenerator.discover_markdown_file_paths(
             self.generator_settings.source_directory, self.generator_settings.skip_files)
 
         # Last chance to process any file paths
         markdown_file_paths = self._process_file_path_list(markdown_file_paths)
 
         # Convert a list of file paths into a list of markdown files, async chunked work
-        markdown_files = await DefaultFeedGenerator.chunked_work(
-            markdown_file_paths, self._file_paths_to_markdown_files, self.generator_settings.async_work_group_size)
+        markdown_files = DefaultFeedGenerator.parallel_work(
+            markdown_file_paths, self._process_file_path_to_markdown_file)
 
         # Convert a list of markdown files into a list of feed items, async chunked work
-        feed_items = await DefaultFeedGenerator.chunked_work(
-            markdown_files, self._markdown_files_to_feed_items, self.generator_settings.async_work_group_size)
+        feed_items = DefaultFeedGenerator.parallel_work(
+            markdown_files, self._process_markdown_file_to_feed_item)
 
         # Sort the feed items
         feed_items = self._sort_feed_items(feed_items)
 
         # Page tracking
         current_page = 1
         feed_items_per_export = self.generator_settings.feed_items_per_export
         total_pages = ceil(len(feed_items) / feed_items_per_export) if feed_items_per_export else 1
 
         # Convert feed items into a feed and export the feed
+        exportable_feeds = []
         for chunked_feed_items in DefaultFeedGenerator.chunk(feed_items, feed_items_per_export):
             # Convert feed items into a feed
             feed = self._feed_items_to_feed(
                 chunked_feed_items, current_page, total_pages, len(feed_items))
 
             # Check the feed is valid
             feed.check()
 
-            logging.info(f'Successfully created feed with {len(feed.feed_items)} items.')
+            logging.info(f'Successfully created feed with {len(feed.items)} items.')
 
-            # Export the feed
-            self._export_feed(feed)
+            # Add feed to list of exportable feeds
+            exportable_feeds.append(feed)
 
             current_page += 1
 
-    def run_standalone(self):
+        # Export the completed feed
+        await DefaultFeedGenerator.async_work(exportable_feeds, self._export_feed)
+
+    def run_standalone(
+        self
+    ):
         """
         Run this in synchronous mode.
         """
         logging.info(f'Running feed generator in standalone mode.')
         asyncio.run(self.run())
 
-    def _check_settings(self):
+    def _check_settings(
+        self
+    ):
         """
         Check the settings to ensure they contain the correct values for this generator.
         """
         pass
 
-    def _check_feed_item(self, feed_item: FeedItem):
+    def _check_feed_item(
+        self,
+        feed_item: FeedItem
+    ):
         """
         Check if a feed item is valid or not.
         """
-        pass
+        feed_item.check()
 
-    def _sort_feed_items(self, feed_items: [FeedItem]) -> [FeedItem]:
+    def _sort_feed_items(
+        self,
+        feed_items: [FeedItem]
+    ) -> [FeedItem]:
         """
         Sort a list of feed items. Override this to provided custom sorting.
         """
         return feed_items
 
-    def _process_markdown_file(self, markdown_file: MarkdownFile) -> MarkdownFile:
+    def _process_markdown_file(
+        self,
+        markdown_file: MarkdownFile
+    ) -> MarkdownFile:
         """
         Perform any needed processing on a markdown file.
         """
         return markdown_file
 
-    def _file_path_to_markdown_file(self, file_path: str) -> MarkdownFile:
+    def _transform_markdown_file_to_feed_item(
+        self,
+        markdown_file: MarkdownFile
+    ) -> FeedItem:
         """
-        Convert a file path to a markdown file.
-        """
-        return MarkdownFile.load(file_path)
-
-    def _markdown_file_to_feed_item(self, markdown_file: MarkdownFile) -> FeedItem:
-        """
-        Convert a markdown file to a feed item.
+        Transform a markdown file to a feed item.
         """
         feed_item = FeedItem()
         feed_item.set('url', markdown_file.file_path)
         feed_item.inject(markdown_file.front_matter)
         return feed_item
 
-    def _process_file_path_list(self, file_paths: list) -> list:
+    def _process_markdown_file_to_feed_item(
+        self,
+        markdown_file: MarkdownFile
+    ) -> FeedItem:
         """
-        Perform any processing on file paths.
+        Process a markdown file. This function will convert a markdown file into a feed item, check its validity
+        and the return it.
         """
-        return file_paths
-
-    async def _file_paths_to_markdown_files(self, file_paths: [str]) -> [MarkdownFile]:
-        """
-        Convert a list of file paths into a list of markdown files.
-        """
-        markdown_files = []
-
-        for file_path in file_paths:
-            markdown_file = self._file_path_to_markdown_file(file_path)
+        feed_item = self._transform_markdown_file_to_feed_item(markdown_file)
 
-            logging.info(f'Successfully converted file path "{file_path}" to markdown file.')
+        logging.info(f'Successfully converted markdown file "{markdown_file}" to feed item.')
 
-            markdown_file = self._process_markdown_file(markdown_file)
+        # Check all the feed items are valid
+        self._check_feed_item(feed_item)
 
-            logging.info(f'Successfully processed markdown file "{markdown_file.file_path}".')
+        return feed_item
 
-            markdown_files.append(markdown_file)
+    def _process_file_path_list(
+        self,
+        file_paths: list
+    ) -> list:
+        """
+        Perform any processing on file paths.
+        """
+        return file_paths
 
-        return markdown_files
+    def _transform_file_path_to_markdown_file(
+        self,
+        file_path: str
+    ) -> MarkdownFile:
+        """
+        Transform a file path to a markdown file.
+        """
+        return MarkdownFile.load(file_path)
 
-    async def _markdown_files_to_feed_items(self, markdown_files: [MarkdownFile]) -> [FeedItem]:
+    def _process_file_path_to_markdown_file(
+        self,
+        file_path: str
+    ) -> MarkdownFile:
         """
-        Convert a list of file paths into a list of markdown files.
+        Process a file path. This function takes a file path, transforms it into a markdown file, calls a process
+        function on the markdown file and then returns it.
         """
-        feed_items = []
+        markdown_file = self._transform_file_path_to_markdown_file(file_path)
 
-        for markdown_file in markdown_files:
-            feed_items.append(
-                self._markdown_file_to_feed_item(markdown_file))
+        logging.info(f'Successfully converted file path "{file_path}" to markdown file.')
 
-            logging.info(f'Successfully converted markdown file "{markdown_file.file_path}" to feed item.')
+        markdown_file = self._process_markdown_file(markdown_file)
 
-        # Check all the feed items are valid
-        [self._check_feed_item(feed_item) for feed_item in feed_items]
+        logging.info(f'Successfully processed markdown file "{markdown_file}".')
 
-        return feed_items
+        return markdown_file
 
-    def _feed_items_to_feed(self, feed_items: [FeedItem], page: int, total_pages: int, total_items: int) -> Feed:
+    def _feed_items_to_feed(
+        self,
+        feed_items: [FeedItem],
+        page: int,
+        total_pages: int,
+        total_items: int
+    ) -> Feed:
         """
         Convert a list of feed items to a feed.
         """
         feed = self._create_feed()
         feed.page = page
-        feed.feed_items = feed_items
+        feed.items = feed_items
         feed.total_pages = total_pages
         feed.total_items = total_items
-        feed.merge(self.feed_details)
+        feed.merge(self.feed)
         return feed
 
-    def _create_feed(self) -> Feed:
+    def _create_feed(
+        self
+    ) -> Feed:
         """
         Create a new feed instance.
         """
         return Feed()
 
-    def _export_feed(self, feed: Feed):
+    async def _export_feed(
+        self,
+        feed: Feed
+    ):
         """
         Export a feed.
         """
         print(json.dumps(feed.dump(), indent=2))
 
     @staticmethod
-    async def chunked_work(work_items: list, process_list_fn: Callable, work_size: int = 10) -> list:
+    def parallel_work(
+        work_items: list,
+        process_list_fn: Callable
+    ) -> list:
         """
         This function takes a list of work items, chunks them into lists of a specified size and then
         calls a process callback function over each of those chunks. This function allows you to run chunks of work
         in parallel. The function will then await completion of all the work chunks and return the processed list.
         """
-        futures = []
-        for file_list_chunk in DefaultFeedGenerator.chunk(work_items, work_size):
-            futures.append(
-                process_list_fn(file_list_chunk))
-
-        processed = []
-        for work_group in await asyncio.gather(*futures):
-            processed += [m for m in work_group]
+        with ThreadPoolExecutor() as ex:
+            futures = [ex.submit(process_list_fn, work_item) for work_item in work_items]
+
+        logging.info(f'Successfully completed parallel work on {len(work_items)} work items.')
+
+        return [future.result() for future in futures]
+
+    @staticmethod
+    async def async_work(
+        work_items: list,
+        process_list_fn: Callable
+    ) -> tuple:
+        """
+        Run a list of work_items through an async function process_list_fn and then await all the results, and
+        then return.
+        """
+        futures = [process_list_fn(work_item) for work_item in work_items]
 
-        logging.info(f'Successfully completed work on {len(work_items)} work items.')
+        logging.info(f'Successfully completed async work on {len(work_items)} work items.')
 
-        return processed
+        return await asyncio.gather(*futures)
 
     @staticmethod
-    def discover_markdown_file_paths(directory_path: str, skip_files: list = None) -> [str]:
+    def discover_markdown_file_paths(
+        directory_path: str,
+        skip_files: list = None
+    ) -> [str]:
         """
         Discover all markdown files within a provided directory, skipping some files if needed.
         """
         if skip_files is None:
             skip_files = []
 
         if not os.path.isdir(directory_path):
             raise Exception(f'The provided path "{directory_path}", must be a directory.')
 
-        return list(filter(
+        return list(
+            filter(
                 lambda x: os.path.basename(x) not in skip_files,
                 [str(path) for path in Path(directory_path).glob('**/*.md')]))
 
     @staticmethod
-    def chunk(items: list, length: int = None) -> list:
+    def chunk(
+        items: list,
+        length: int = None
+    ) -> list:
         """
         Chunk a list into a specific length. If no length is provided, just yield the original list.
         """
         if length is None:
             yield items
             return
```

## markdownfeedgenerator/Generators/Default/DefaultFeedGeneratorSettings.py

```diff
@@ -23,17 +23,18 @@
             self.target_directory = self.target_directory.rstrip(os.sep)
 
         self.skip_files = skip_files
 
         if not self.skip_files:
             self.skip_files = []
 
-    def check(self):
+    def check(
+        self
+    ):
         pass
 
-    def __str__(self):
-        return json.dumps({
-            'work_group_size': self.async_work_group_size,
-            'feed_items_per_export': self.feed_items_per_export,
-            'source_directory': self.source_directory,
-            'target_directory': self.target_directory,
-        })
+    def __str__(
+        self
+    ):
+        return json.dumps(
+            {'work_group_size': self.async_work_group_size, 'feed_items_per_export': self.feed_items_per_export,
+             'source_directory': self.source_directory, 'target_directory': self.target_directory, })
```

## markdownfeedgenerator/Generators/Default/Models/Feed.py

```diff
@@ -1,26 +1,63 @@
+from typing import Self
+
 from markdownfeedgenerator.Generators.Default.Models import ItemStore
 from markdownfeedgenerator.Generators.Default.Models.FeedItem import FeedItem
 
 
-class Feed(ItemStore):
-    def __init__(self, items: dict = None):
-        ItemStore.__init__(self)
+class Feed:
+    def __init__(
+        self
+    ):
+        self.store = ItemStore()
 
-        self.feed_items: [FeedItem] = []
+        self.items: [FeedItem] = []
         self.page = None
         self.total_pages = None
         self.total_items = None
 
-        if items:
-            self.inject(items)
+    def set(
+        self,
+        key: str,
+        data: any
+    ) -> any:
+        self.store.set(key, data)
+
+    def has(
+        self,
+        key: str
+    ) -> bool:
+        return self.store.has(key)
+
+    def get(
+        self,
+        key: str
+    ) -> any:
+        return self.store.get(key)
+
+    def inject(
+        self,
+        values_to_inject: dict
+    ):
+        for key in values_to_inject:
+            self.store.set(key, values_to_inject[key])
+
+    def merge(
+        self,
+        item_store: Self
+    ):
+        self.inject(item_store.dump())
+
+    def check(
+        self
+    ):
+        self.store.check()
+
+    def dump(
+        self
+    ) -> dict:
+        self.store.set('items', self.items)
+        self.store.set('page', self.page)
+        self.store.set('total_pages', self.total_pages)
+        self.store.set('total_items', self.total_pages)
 
-    def check(self):
-        if not self.has('title'):
-            raise ValueError('The feed item does not have a valid title.')
-
-    def dump(self) -> dict:
-        self.set('items', [x.dump() for x in self.feed_items])
-        self.set('page', self.page)
-        self.set('total_pages', self.total_pages)
-        self.set('total_items', self.total_items)
-        return super().dump()
+        return self.store.dump()
```

## markdownfeedgenerator/Generators/Default/Models/FeedItem.py

```diff
@@ -1,6 +1,8 @@
 from markdownfeedgenerator.Generators.Default.Models import ItemStore
 
 
 class FeedItem(ItemStore):
-    def __init__(self):
+    def __init__(
+        self
+    ):
         ItemStore.__init__(self)
```

## markdownfeedgenerator/Generators/Default/Models/__init__.py

```diff
@@ -1,40 +1,87 @@
+from typing import Self
+
+
 class ItemStore:
-    def __init__(self, initial_values: dict = None):
+    def __init__(
+        self,
+        initial_values: dict = None
+    ):
         if initial_values:
             self.store = initial_values
         else:
             self.store = {}
 
-    def set(self, key: str, data: any) -> any:
+    def set(
+        self,
+        key: str,
+        data: any
+    ) -> any:
         self.store[key] = data
 
-    def has(self, key: str) -> bool:
+    def has(
+        self,
+        key: str
+    ) -> bool:
         return key in self.store
 
-    def get(self, key: str) -> any:
+    def has_value(
+        self,
+        key: str
+    ) -> bool:
+        """
+        Check if a value exists and it is not None.
+        """
         if not self.has(key):
-            raise ValueError(f'Feed details store contains no value with key "{key}".')
+            return False
 
-        return self.store[key]
+        return self.get(key)
 
-    def inject(self, values_to_inject: dict):
-        for key in values_to_inject:
-            self.set(key, values_to_inject[key])
+    def get(
+        self,
+        key: str
+    ) -> any:
+        if not self.has(key):
+            available_values = list(self.store.keys())
+            raise ValueError(f'Feed details store contains no value with key "{key}", values are "{available_values}".')
 
-    def merge(self, item_store: any):
-        self.store = {**self.store, **item_store.store}
+        return self.store[key]
 
-    def dump(self) -> dict:
+    def inject(
+        self,
+        values_to_inject: dict
+    ):
+        [self.set(key, values_to_inject[key]) for key in values_to_inject]
+
+    def merge(
+        self,
+        item_store: Self
+    ):
+        [self.set(key, item_store.get(key)) for key in item_store.store]
+
+    def check(
+        self
+    ):
+        pass
+
+    def prepare_export_value(
+        self,
+        value: any
+    ):
+        if isinstance(value, ItemStore):
+            return value.dump()
+        elif isinstance(value, list):
+            return [self.prepare_export_value(inner_value) for inner_value in value]
+
+        return value
+
+    def dump(
+        self
+    ) -> dict:
         dump = {}
         for key in self.store:
-            value = self.store[key]
+            prepared = self.prepare_export_value(self.store[key])
 
-            if isinstance(value, ItemStore):
-                dump[key] = value.dump()
-            elif isinstance(value, list):
-                if len(value) > 0:
-                    dump[key] = value
-            elif value is not None:
-                dump[key] = value
+            if prepared is not None:
+                dump[key] = prepared
 
         return dump
```

## markdownfeedgenerator/Generators/Html/HtmlFeedGenerator.py

```diff
@@ -8,58 +8,56 @@
 from markdownfeedgenerator.Generators.Json.JsonFeedGenerator import JsonFeedGenerator
 from markdownfeedgenerator.Generators.Json.JsonFeedGeneratorSettings import JsonFeedGeneratorSettings
 from markdownfeedgenerator.Generators.Json.Models.JsonFeed import JsonFeed
 
 
 class HtmlFeedGenerator(JsonFeedGenerator):
     # Default template path
-    DEFAULT_TEMPLATE = os.path.join(
-        os.path.dirname(os.path.realpath(__file__)), 'template.html')
+    DEFAULT_TEMPLATE = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'template.html')
 
-    def __init__(self, feed_details: JsonFeed = None, generator_settings: JsonFeedGeneratorSettings = None,
-                 template_file_path: str = None):
+    def __init__(
+        self,
+        feed: JsonFeed = None,
+        generator_settings: JsonFeedGeneratorSettings = None,
+        template_file_path: str = None
+    ):
 
-        JsonFeedGenerator.__init__(self, feed_details, generator_settings)
+        JsonFeedGenerator.__init__(self, feed, generator_settings)
         self.template_file_path = template_file_path
 
-    def _export_feed(self, feed: Feed):
+    async def _export_feed(
+        self,
+        feed: Feed
+    ):
         """
         Export a feed.
         """
         feed_url = self.get_feed_page_name(feed.page)
         next_feed_url = self.get_feed_page_name(feed.page + 1) if (feed.page + 1) < feed.total_pages else None
-        previous_feed_url = self.get_feed_page_name(feed.page - 1) if feed.page > 0 else None
+        previous_feed_url = self.get_feed_page_name(feed.page - 1) if feed.page > 1 else None
         feed_file_target = os.path.join(self.generator_settings.target_directory, feed_url)
 
         if self.generator_settings.feed_base_url:
             previous_feed_url = self.generator_settings.feed_base_url + '/' + previous_feed_url
 
         if self.generator_settings.feed_base_url:
             next_feed_url = self.generator_settings.feed_base_url + '/' + next_feed_url
 
-        template = read_from_file(
-            os.path.join(
-                os.path.dirname(os.path.realpath(__file__)), 'template.html'))
-
-        content = chevron.render(template, {**{
-            'nextPageUrl':
-                next_feed_url,
-            'previousPageUrl':
-                previous_feed_url,
-            'title':
-                feed.get('title'),
-            'files':
-                [f.dump() for f in feed.feed_items]
-        }, **feed.dump()})
+        template = read_from_file(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'template.html'))
 
-        write_to_file(
-            feed_file_target, content)
+        content = chevron.render(
+            template, {
+                **{'nextPageUrl': next_feed_url, 'previousPageUrl': previous_feed_url, 'title': feed.get('title'),
+                    'files': [f.dump() for f in feed.items]}, **feed.dump()})
 
-        logging.info(
-            f'Successfully wrote feed page to "{feed_file_target}".')
+        write_to_file(feed_file_target, content)
+
+        logging.info(f'Successfully wrote feed page to "{feed_file_target}".')
 
     @staticmethod
-    def get_feed_page_name(page_number: int) -> str:
+    def get_feed_page_name(
+        page_number: int
+    ) -> str:
         if page_number <= 1:
             return 'index.html'
 
         return f'{page_number}.html'
```

## markdownfeedgenerator/Generators/Json/JsonFeedGenerator.py

```diff
@@ -1,69 +1,88 @@
 import json
 import logging
 import os
 
 from markdownfeedgenerator import write_to_file
+from markdownfeedgenerator.Generators.Default.DefaultFeedGenerator import DefaultFeedGenerator
+from markdownfeedgenerator.Generators.Default.Models.Feed import Feed
 from markdownfeedgenerator.Generators.Json import JsonFeedGeneratorSettings
 from markdownfeedgenerator.Generators.Json.Models.JsonFeed import JsonFeed
 from markdownfeedgenerator.Generators.Json.Models.JsonFeedItem import JsonFeedItem
 from markdownfeedgenerator.MarkdownFile import MarkdownFile
-from markdownfeedgenerator.Generators.Default.DefaultFeedGenerator import DefaultFeedGenerator
-from markdownfeedgenerator.Generators.Default.Models.Feed import Feed
 
 
 class JsonFeedGenerator(DefaultFeedGenerator):
     # JSON Feed version
     JSON_FEED_VERSION = f'https://jsonfeed.org/version/1'
 
-    def __init__(self, feed_details: JsonFeed, generator_settings: JsonFeedGeneratorSettings):
+    def __init__(
+        self,
+        feed: JsonFeed,
+        generator_settings: JsonFeedGeneratorSettings
+    ):
         """
         Constructor
         """
-        feed_details.set('version', JsonFeedGenerator.JSON_FEED_VERSION)
-        DefaultFeedGenerator.__init__(self, feed_details, generator_settings)
+        feed.set('version', JsonFeedGenerator.JSON_FEED_VERSION)
+
+        DefaultFeedGenerator.__init__(self, feed, generator_settings)
+
         self.generator_settings = generator_settings
 
-    def _check_settings(self):
+    def _check_settings(
+        self
+    ):
         """
         Check feed settings
         """
         if not self.generator_settings.source_directory:
             self.generator_settings.source_directory = os.getcwd()
 
         if not self.generator_settings.target_directory:
             self.generator_settings.target_directory = os.path.join(os.getcwd(), 'feed')
 
-    def _create_feed(self) -> JsonFeed:
+    def _create_feed(
+        self
+    ) -> JsonFeed:
         """
         Create a new feed instance.
         """
         return JsonFeed()
 
-    def _markdown_file_to_feed_item(self, markdown_file: MarkdownFile) -> JsonFeedItem:
+    def _process_markdown_file_to_feed_item(
+        self,
+        markdown_file: MarkdownFile
+    ) -> JsonFeedItem:
         """
         Convert a markdown file to a feed item.
         """
         feed_item = JsonFeedItem()
         feed_item.set('id', markdown_file.id)
         feed_item.set('url', markdown_file.file_path)
         feed_item.set('date_published', markdown_file.date.isoformat() if markdown_file.date else None)
         feed_item.set('summary', markdown_file.summary)
         feed_item.inject(markdown_file.front_matter)
         feed_item = self._inject_feed_item_details(feed_item, markdown_file)
         return feed_item
 
     def _inject_feed_item_details(
-            self, feed_item_details: JsonFeedItem, markdown_file: MarkdownFile) -> JsonFeedItem:
+        self,
+        feed_item_details: JsonFeedItem,
+        markdown_file: MarkdownFile
+    ) -> JsonFeedItem:
         """
         Inject any additional feed item details.
         """
         return feed_item_details
 
-    def _export_feed(self, feed: Feed):
+    async def _export_feed(
+        self,
+        feed: Feed
+    ):
         """
         Export a feed.
         """
         feed_url = 'feed.json' if feed.page == 1 else f'{feed.page - 1}.json'
         next_feed_url = f'{feed.page}.json' if feed.page < feed.total_pages else None
         feed_file_target = os.path.join(self.generator_settings.target_directory, feed_url)
 
@@ -72,12 +91,10 @@
 
         if self.generator_settings.feed_base_url and next_feed_url:
             next_feed_url = f'{self.generator_settings.feed_base_url}/{next_feed_url}'
 
         feed.set('feed_url', feed_url)
         feed.set('next_url', next_feed_url)
 
-        write_to_file(
-            feed_file_target, json.dumps(feed.dump(), indent=2))
+        write_to_file(feed_file_target, json.dumps(feed.dump(), indent=2))
 
-        logging.info(
-            f'Successfully wrote feed page to "{feed_file_target}".')
+        logging.info(f'Successfully wrote feed page to "{feed_file_target}".')
```

## markdownfeedgenerator/Generators/Json/JsonFeedGeneratorSettings.py

```diff
@@ -5,18 +5,13 @@
     def __init__(
         self,
         async_work_group_size: int = 10,
         feed_items_per_export: int = 100,
         source_directory: str = None,
         target_directory: str = None,
         skip_files: list = None,
-        feed_base_url: str = '',
+        feed_base_url: str = ''
     ):
         DefaultFeedGeneratorSettings.__init__(
-            self,
-            async_work_group_size,
-            feed_items_per_export,
-            source_directory,
-            target_directory,
-            skip_files)
+            self, async_work_group_size, feed_items_per_export, source_directory, target_directory, skip_files)
 
         self.feed_base_url = feed_base_url
```

## markdownfeedgenerator/Generators/Json/Models/Author.py

```diff
@@ -1,22 +1,27 @@
-from markdownfeedgenerator.Generators.Json.Models import JsonFeedItemStore
+from markdownfeedgenerator.Generators.Json.Models import JsonFeedItemStoreSync
 
 
-class Author(JsonFeedItemStore):
+class Author(JsonFeedItemStoreSync):
     """
     Represents the properties of an author.
     """
+
     def __init__(
         self,
         name: str = None,
         url: str = None,
         avatar: str = None
     ):
-        JsonFeedItemStore.__init__(self, ['name', 'url', 'avatar'])
+        JsonFeedItemStoreSync.__init__(self, ['name', 'url', 'avatar'])
 
-        self.set('name', name)
-        self.set('url', url)
-        self.set('avatar', avatar)
+        self.name = name
+        self.url = url
+        self.avatar = avatar
 
-    def check(self):
-        if not self.has('name') and not self.has('url') and not self.has('avatar'):
+    def check(
+        self
+    ):
+        if not self.has_value('name') and not self.has_value('url') and not self.has_value('avatar'):
             raise ValueError('You must provide a value for at least one of the "name", "url" or "avatar" properties.')
+
+        super().check()
```

## markdownfeedgenerator/Generators/Json/Models/Hub.py

```diff
@@ -1,20 +1,25 @@
-from markdownfeedgenerator.Generators.Json.Models import JsonFeedItemStore
+from markdownfeedgenerator.Generators.Json.Models import JsonFeedItemStoreSync
 
 
-class Hub(JsonFeedItemStore):
+class Hub(JsonFeedItemStoreSync):
     """
     Represents the properties of a hub.
     """
+
     def __init__(
         self,
         hub_type: str = None,
         url: str = None
     ):
-        JsonFeedItemStore.__init__(self, ['type', 'url'])
+        JsonFeedItemStoreSync.__init__(self, ['type', 'url'])
 
-        self.set('type', hub_type)
-        self.set('url', url)
+        self.type = hub_type
+        self.url = url
 
-    def check(self):
+    def check(
+        self
+    ):
         if not self.has('type') or not self.has('url'):
             raise ValueError('You must provide a valid value for both "type" and "url".')
+
+        super().check()
```

## markdownfeedgenerator/Generators/Json/Models/JsonFeed.py

```diff
@@ -1,10 +1,11 @@
+from markdownfeedgenerator.Generators.Default.Models.Feed import Feed
+from markdownfeedgenerator.Generators.Json.Models import JsonFeedItemStore
 from markdownfeedgenerator.Generators.Json.Models.Author import Author
 from markdownfeedgenerator.Generators.Json.Models.Hub import Hub
-from markdownfeedgenerator.Generators.Default.Models.Feed import Feed
 
 
 class JsonFeed(Feed):
     def __init__(
         self,
         version: str | None = None,
         title: str | None = None,
@@ -17,41 +18,35 @@
         fav_icon: str | None = None,
         author: Author | None = None,
         expired: bool | None = None,
         hubs: [Hub] = None
     ):
         Feed.__init__(self)
 
-        self.protected_keys = ['version', 'title', 'home_page_url', 'feed_url', 'description', 'feed', 'items',
-                               'user_comment', 'next_url', 'icon', 'fav_icon', 'author', 'expired', 'hubs']
-
-        if not hubs:
-            hubs = []
+        self.store = JsonFeedItemStore(
+            ['version', 'title', 'home_page_url', 'feed_url', 'description', 'feed', 'items', 'user_comment',
+                'next_url', 'icon', 'fav_icon', 'author', 'expired', 'hubs'])
+
+        self.version = version
+        self.title = title
+        self.home_page_url = home_page_url
+        self.feed_url = feed_url
+        self.description = description
+        self.user_comment = user_comment
+        self.next_url = next_url
+        self.icon = icon
+        self.fav_icon = fav_icon
+        self.author = author
+        self.expired = expired
+        self.hubs = hubs if hubs else []
 
-        self.set('version', version)
-        self.set('title', title)
-        self.set('home_page_url', home_page_url)
-        self.set('feed_url', feed_url)
-        self.set('description', description)
-        self.set('user_comment', user_comment)
-        self.set('next_url', next_url)
-        self.set('icon', icon)
-        self.set('fav_icon', fav_icon)
-        self.set('author', author)
-        self.set('expired', expired)
-        self.set('hubs', hubs)
-        self.set('extensions', expired)
-
-    def set(self, key: str, data: any) -> any:
-        if key == 'author' and isinstance(key, Author):
-            raise ValueError('Author must be an instance of AuthorDetails.')
-
-        if key == 'hubs':
-            for hub in data:
-                if isinstance(hub, Hub):
-                    raise ValueError('Hub value must be an instance of HubDetails.')
-
-        if key in self.protected_keys:
-            super().set(key, data)
-            return
+    def __setattr__(
+        self,
+        key,
+        value
+    ):
+        if hasattr(self, 'store'):
+            store = getattr(self, 'store')
+            if hasattr(store, 'protected_keys') and key in store.protected_keys:
+                self.set(key, value)
 
-        super().set(f'_{key}', data)
+        return super().__setattr__(key, value)
```

## markdownfeedgenerator/Generators/Json/Models/JsonFeedItem.py

```diff
@@ -1,42 +1,41 @@
-from markdownfeedgenerator.Generators.Json.Models import JsonFeedItemStore
+from markdownfeedgenerator.Generators.Json.Models import JsonFeedItemStoreSync
 from markdownfeedgenerator.Generators.Json.Models.Author import Author
 
 
-class JsonFeedItem(JsonFeedItemStore):
+class JsonFeedItem(JsonFeedItemStoreSync):
     def __init__(
         self,
-        id: str | None = None,
+        _id: str | None = None,
         url: str | None = None,
         external_url: str | None = None,
         title: str | None = None,
         content_html: str | None = None,
         content_text: str | None = None,
         summary: str | None = None,
         image: str | None = None,
         banner_image: str | None = None,
         date_published: str | None = None,
         date_modified: Author | None = None,
         author: Author | None = None,
         tags: [str] = None
     ):
-        JsonFeedItemStore.__init__(self, ['id', 'url', 'external_url', 'title', 'content_html', 'content_text',
-                                          'summary', 'image', 'banner_image', 'date_published', 'date_modified',
-                                          'author', 'tags'])
-
-        if not tags:
-            tags = []
-
-        self.set('id', id)
-        self.set('url', url)
-        self.set('external_url', external_url)
-        self.set('title', title)
-        self.set('content_html', content_html)
-        self.set('content_text', content_text)
-        self.set('summary', summary)
-        self.set('image', image)
-        self.set('banner_image', banner_image)
-        self.set('date_published', date_published)
-        self.set('date_modified', date_modified)
-        self.set('author', author)
-        self.set('tags', tags)
+        JsonFeedItemStoreSync.__init__(
+            self,
+            ['id', 'url', 'external_url', 'title', 'content_html', 'content_text', 'summary', 'image', 'banner_image',
+             'date_published', 'date_modified', 'author', 'tags'])
 
+        # Mostly for convenience, we could also just use the store, but this makes it easier for JsonFeedItem references
+        # to know exactly what can be customized.
+        self.id = _id
+        self.url = url
+        self.external_url = external_url
+        self.title = title
+        self.content_html = content_html
+        self.content_text = content_text
+        self.summary = summary
+        self.image = image
+        self.banner_image = banner_image
+        self.date_published = date_published
+        self.date_modified = date_modified
+        self.author = author
+        self.tags = tags if tags else []
```

## markdownfeedgenerator/Generators/Json/Models/__init__.py

```diff
@@ -1,18 +1,80 @@
 from markdownfeedgenerator.Generators.Default.Models import ItemStore
 
 
 class JsonFeedItemStore(ItemStore):
-    def __init__(self, protected_keys: list = None):
+    def __init__(
+        self,
+        protected_keys: list = None
+    ):
         ItemStore.__init__(self)
 
-        if not protected_keys:
-            protected_keys = []
+        self.protected_keys = protected_keys if protected_keys else []
 
-        self.protected_keys = protected_keys
+        [self.set(pk, None) for pk in self.protected_keys]
+
+    def get(
+        self,
+        key: str
+    ) -> any:
+        if f'_{key}' in self.store:
+            return self.store[f'_{key}']
+
+        return super().get(key)
+
+    def has(
+        self,
+        key: str
+    ) -> any:
+        if key.startswith('_'):
+            key = key.lstrip('_')
+
+        if f'_{key}' in self.store:
+            return True
+
+        return super().has(key)
+
+    def is_protected(
+        self,
+        key: str
+    ) -> bool:
+        """
+        Check if a key is in the protected key list.
+        """
+        return key in self.protected_keys
+
+    def set(
+        self,
+        key: str,
+        data: any
+    ) -> any:
+        if key.startswith('_'):
+            key = key.lstrip('_')
 
-    def set(self, key: str, data: any) -> any:
         if key in self.protected_keys:
             super().set(key, data)
             return
 
         super().set(f'_{key}', data)
+
+    def dump(
+        self
+    ) -> dict:
+        return super().dump()
+
+
+class JsonFeedItemStoreSync(JsonFeedItemStore):
+    def __init__(
+        self,
+        protected_keys: list = None
+    ):
+        JsonFeedItemStore.__init__(self, protected_keys)
+
+    def __setattr__(
+        self,
+        key,
+        value
+    ):
+        if hasattr(self, 'protected_keys') and key in self.protected_keys:
+            self.set(key, value)
+
+        return super().__setattr__(key, value)
```

## Comparing `markdownfeedgenerator-2.2.0.dist-info/LICENSE` & `markdownfeedgenerator-2.3.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `markdownfeedgenerator-2.2.0.dist-info/METADATA` & `markdownfeedgenerator-2.3.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: markdownfeedgenerator
-Version: 2.2.0
+Version: 2.3.0
 Summary: Small library that can generated paged feeds (json, html, etc) based on a collection of markdown files.
 Author-email: Scott Straughan <dev@null.com>
 Project-URL: Homepage, https://github.com/scottstraughan/markdownfeedgenerator
 Project-URL: Issues, https://github.com/scottstraughan/markdownfeedgenerator/issues
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
```

## Comparing `markdownfeedgenerator-2.2.0.dist-info/RECORD` & `markdownfeedgenerator-2.3.0.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-markdownfeedgenerator/Gatherer.py,sha256=Q4ZXse8xEf85oooTr4O9u3mNndzvpdgdYEtrJOig-FQ,607
-markdownfeedgenerator/MarkdownFile.py,sha256=xA_xhi755WqcZJDdeN1DHAbaba1p74A58-JHhqI9pqc,4962
-markdownfeedgenerator/__init__.py,sha256=ujJ8VTzqrsShrpvIEe_VeULvClqjiADBQj95e8SWeO8,1158
+markdownfeedgenerator/Gatherer.py,sha256=WhkfrNNPAjVTH2uBMcGZhaL6PmMTm7CZ7q8OiByU9UY,645
+markdownfeedgenerator/MarkdownFile.py,sha256=W0sC89jyIiQ5Dxd_Jq_B5vU_TPAgj6LPwru6PY-l02o,5507
+markdownfeedgenerator/__init__.py,sha256=Pv-X_6IDigwFMSqaSI5vyrMMz8XLaMilRxXdcvf_IjQ,1192
 markdownfeedgenerator/Exceptions/__init__.py,sha256=D1XJBiMmaOxZbQt--f_E9wVgniupUipBLor9Svq7yMY,341
-markdownfeedgenerator/Generators/Default/DefaultFeedGenerator.py,sha256=BmFs3aMjUf_-RXehB0yXPI2NaxGN7dnzpWzO46i80jM,8259
-markdownfeedgenerator/Generators/Default/DefaultFeedGeneratorSettings.py,sha256=n5xoOQsqi7c6Qji9j3FXP3QDj9gDrn_wrdMsj8DaLnw,1158
-markdownfeedgenerator/Generators/Default/Models/Feed.py,sha256=MzmU6ViZQSPN65vKZT1M7Qjof0o4nJgq-qlsRXqpc0M,820
-markdownfeedgenerator/Generators/Default/Models/FeedItem.py,sha256=375xlmD3Q51CpPwNXxCwF6nQ0OaGfTuXae2kl2aNov8,156
-markdownfeedgenerator/Generators/Default/Models/__init__.py,sha256=Wq7Pj9vI_s1eMA1Tqy472_V4koaoFdu6rcXXnCxQ__8,1151
-markdownfeedgenerator/Generators/Html/HtmlFeedGenerator.py,sha256=h8Iqb9mfGmrDCwSRjV6i4wlLKbViTUiYJh6x8Gisnpk,2430
+markdownfeedgenerator/Generators/Default/DefaultFeedGenerator.py,sha256=ssdi-FW_mofH2GaaH68AtP54HLlpA7iRlL4maSGiGxE,8952
+markdownfeedgenerator/Generators/Default/DefaultFeedGeneratorSettings.py,sha256=erhr8b9qFBopSSP68TPxEl6neag3t4fdKRZ0bzKO-nA,1155
+markdownfeedgenerator/Generators/Default/Models/Feed.py,sha256=JRwfdETPi62z-xsgMBQzzAqtca79dExfEqNBILsAuXg,1285
+markdownfeedgenerator/Generators/Default/Models/FeedItem.py,sha256=LP4rwvt9i8gZaEDFWQ4pnenASV3QFUhQWuv3IUxl7XU,170
+markdownfeedgenerator/Generators/Default/Models/__init__.py,sha256=eynyaElCIuDHRR3l9w9k8iVYWTqNw32cltlQKWNAbGg,1824
+markdownfeedgenerator/Generators/Html/HtmlFeedGenerator.py,sha256=GwoKN-e7t-LBWlT4R7_JojSGzM4A6RK-EIDEU-iEteg,2335
 markdownfeedgenerator/Generators/Html/template.html,sha256=XwzC8DPAHKCLCh1FAPsyAlIFkbo8wvtH4O0zkt_Xd08,2753
-markdownfeedgenerator/Generators/Json/JsonFeedGenerator.py,sha256=rfOk_CFraXTr5cqMHP6PT_p9eAvqUlQAvII6-oApgXc,3246
-markdownfeedgenerator/Generators/Json/JsonFeedGeneratorSettings.py,sha256=hfPsuQ3hzRhMoNfmcEAi-QsLCM8zcMVTFUsvIIrUH6Y,703
-markdownfeedgenerator/Generators/Json/Models/Author.py,sha256=B3TpMMamQV1t42RmuH9Sd5pJMURUoqpTAy7aa9XdeIc,676
-markdownfeedgenerator/Generators/Json/Models/Hub.py,sha256=FfUZBwhFEfwqRPabIFI7tVuCy4Bct2hUfQ27fCdzWQI,547
-markdownfeedgenerator/Generators/Json/Models/JsonFeed.py,sha256=wHOcXhkT0HAYazUtwKdwacERsAgFA8B7sdtIu9HVovI,1999
-markdownfeedgenerator/Generators/Json/Models/JsonFeedItem.py,sha256=a07wyZSlOdGqN1SOPKKh6tX2YqIOEyyGHLEhpKzZBQY,1555
-markdownfeedgenerator/Generators/Json/Models/__init__.py,sha256=jek5NE__JC_adeOhw9Uj_ioLENz9IEXxqTLQQmN_oOM,483
-markdownfeedgenerator-2.2.0.dist-info/LICENSE,sha256=uFG9Hrb3ZP-vG6brINYojO6GXRyhN78y_JIJkvJzlRc,1072
-markdownfeedgenerator-2.2.0.dist-info/METADATA,sha256=t5PD_Gl4bnYdIjUm6JGvzuaHk6mO_U8tWLngqZADzLo,3052
-markdownfeedgenerator-2.2.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-markdownfeedgenerator-2.2.0.dist-info/top_level.txt,sha256=MMX9sVjr5zwKRifuaJNujXQY-_IpC_Frmil_mHsj6_c,22
-markdownfeedgenerator-2.2.0.dist-info/RECORD,,
+markdownfeedgenerator/Generators/Json/JsonFeedGenerator.py,sha256=Qk0pj3sp_BaXbkz3Y42kCqOmqvZFpwAyPEwSPdQmcUs,3331
+markdownfeedgenerator/Generators/Json/JsonFeedGeneratorSettings.py,sha256=OSmTkRylLt8TLWlyt7SkI-kM8DPlhkomgzZq_-uEYNg,642
+markdownfeedgenerator/Generators/Json/Models/Author.py,sha256=URthLH-kXoMAfOSdJvDwh5jsWorUIX0_lv6836XNs00,728
+markdownfeedgenerator/Generators/Json/Models/Hub.py,sha256=fWzCm_1_6KomiOz9JGnJCbuV7lBh1bRowMBEZ5zaP7E,587
+markdownfeedgenerator/Generators/Json/Models/JsonFeed.py,sha256=mOZ89a_O9w8eLnr6ZPBgOlXvPhG3lw0dQL-8TiHP7w0,1761
+markdownfeedgenerator/Generators/Json/Models/JsonFeedItem.py,sha256=kQQu91lpCvHz0PDrZDtUVBJcsR3e16vnbPASp3ZNI9c,1587
+markdownfeedgenerator/Generators/Json/Models/__init__.py,sha256=znkT__131OpzrxHtCXEOwlF5QJDw1Mg58Cl5LZuDMk4,1681
+markdownfeedgenerator-2.3.0.dist-info/LICENSE,sha256=uFG9Hrb3ZP-vG6brINYojO6GXRyhN78y_JIJkvJzlRc,1072
+markdownfeedgenerator-2.3.0.dist-info/METADATA,sha256=Jsn-J0-axVVffmuo57ghJ6nWl1Wg-Z-yndCVysqTJo4,3052
+markdownfeedgenerator-2.3.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+markdownfeedgenerator-2.3.0.dist-info/top_level.txt,sha256=MMX9sVjr5zwKRifuaJNujXQY-_IpC_Frmil_mHsj6_c,22
+markdownfeedgenerator-2.3.0.dist-info/RECORD,,
```

